#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Generate supplementary questions (50 additional) for each exam category.
Takes existing 50 problems and adds 50 more to make 100 total per file.
"""

import json
import os
from pathlib import Path

# Define supplementary question data for each category
# Format: {category: {file_path: questions_data}}

SUPPLEMENTARY_QUESTIONS = {
    "sa_security": [
        {
            "id": "sa_security_051",
            "question": "セキュアネットワークアーキテクチャの設計において、境界での防御層が突破された場合の対策として最も重要なものはどれか。",
            "choices": [
                "外部との通信を完全に遮断する",
                "内部ネットワークのマイクロセグメンテーションにより、横展開を制限する",
                "ユーザーアカウント数を削減する",
                "定期的なメンテナンス時間を設定する"
            ],
            "answer": 1,
            "explanation": "多層防御の考え方では、外部境界の防御が完全ではないと想定し、内部においても横展開を制限する設計が重要です。各セグメント間の通信を最小権限原則で制限することで、一つのセグメント侵害時の被害拡大を防ぎます。"
        },
        {
            "id": "sa_security_052",
            "question": "クラウドネイティブ環境でのシークレット管理（API キー、パスワード等）について、最も推奨されるアプローチはどれか。",
            "choices": [
                "シークレットをコード内に埋め込み、バージョン管理で履歴を追跡する",
                "AWS Secrets Manager、Azure Key Vault等の専用サービスで管理し、アプリケーションは実行時に取得する",
                "テキストファイルに保存し、ファイル権限で保護する",
                "環境変数に平文で設定し、ドキュメント化する"
            ],
            "answer": 1,
            "explanation": "専用シークレット管理サービスにより、シークレットをコード外で保管・回転・監査が可能です。アプリケーション内に秘密情報を埋め込まないことで、リポジトリ漏洩時のリスク低減、ローテーション容易化が実現します。"
        },
        {
            "id": "sa_security_053",
            "question": "ネットワークトラフィック分析によるセキュリティ監視（NDR）の主な効果として最も適切なものはどれか。",
            "choices": [
                "帯域幅の最適化のみ",
                "既知のシグネチャにはマッチしない未検出マルウェア、内部脅威、C2通信等を行動分析で検知する",
                "パスワード要件の厳格化",
                "ユーザーログイン数の制限"
            ],
            "answer": 1,
            "explanation": "NDRは通常と異なるネットワーク行動パターンを検知するもので、暗号化通信内でも統計的異常やプロトコル異常を検知できます。既知脅威ベースのシグネチャ検知を補強し、ゼロデイ攻撃やAPT検知に有効です。"
        },
        {
            "id": "sa_security_054",
            "question": "ハイブリッドワークモデルにおけるエンドポイントセキュリティ設計の主要な課題として最も重要なものはどれか。",
            "choices": [
                "オフィスとリモート従業員の区別をなくす",
                "定社外（公開WiFi、個人デバイス等）での安全な業務環境確保、MDM/EDRによる可視性確保",
                "パスワード定期変更のみで対応できる",
                "クラウドストレージへの全アクセスを禁止する"
            ],
            "answer": 1,
            "explanation": "リモート環境では企業管理外のネットワーク・デバイスが使用されます。MDM（Mobile Device Management）で端末管理、EDRで異常検知、VPN/ゼロトラストアーキテクチャで認証・暗号化を確保する必要があります。"
        },
        {
            "id": "sa_security_055",
            "question": "ログのタイムスタンプ管理において、『タイムスタンプサービス』を導入する最大のメリットはどれか。",
            "choices": [
                "ログファイルサイズを削減できる",
                "ログの時刻が改ざんされていないことを、第三者が検証可能にする",
                "ログ取得速度が向上する",
                "ネットワーク遅延が消費される"
            ],
            "answer": 1,
            "explanation": "タイムスタンプサービス（RFC 3161準拠）は認定局から取得したタイムスタンプにより、その時刻にそのログが存在したことを、事後的に第三者が検証可能です。訴訟・フォレンジック対応で証拠能力が高まります。"
        },
        {
            "id": "sa_security_056",
            "question": "デジタル署名（電子署名）を用いたドキュメント完全性検証の実装において、最も重要な要素はどれか。",
            "choices": [
                "署名対象が文書のコピーのみ",
                "署名生成時の秘密鍵安全性、署名検証時の公開鍵真正性（PKI）が確保されていること",
                "署名付与後のドキュメント修正を許可する",
                "署名・検証プロセスを複数人で同時に行わない"
            ],
            "answer": 1,
            "explanation": "デジタル署名の信頼性は『秘密鍵保護』と『公開鍵認証』に依存します。秘密鍵漏洩や、署名検証時の公開鍵出所不明は、署名の意味を失わせます。PKI やCA整備、鍵管理は最も重要な設計要素です。"
        },
        {
            "id": "sa_security_057",
            "question": "セキュリティテストの自動化において、『動的アプリケーションセキュリティテスト（DAST）』と『静的コード解析（SAST）』の関係として最も適切なものはどれか。",
            "choices": [
                "SASTのみで十分であり、DASTは不要",
                "それぞれがカバーの範囲が異なり、両方の組み合わせでより多くの脆弱性を検出できる",
                "DASTはWebアプリケーション限定で使用できない",
                "どちらを選んでも結果は同じ"
            ],
            "answer": 1,
            "explanation": "SAST はソースコード（実行前）の脆弱性を検知し、DAST は実行時の脆弱性を検知します。SASTは誤検知が多く、DAST は検知漏れがあります。両者を組み合わせた『ハイブリッド検査』が、DevSecOps で推奨されます。"
        },
        {
            "id": "sa_security_058",
            "question": "ディザスタリカバリ計画における『復旧戦略の分類』として最も適切なものはどれか。",
            "choices": [
                "RTO/RPOのみで分類する",
                "バックアップ復旧、ホットスタンバイ、アクティブ・アクティブ等、RTO/RPO要件に応じて段階化する",
                "業界標準に依存して決定する",
                "コスト最小化を優先して決定する"
            ],
            "answer": 1,
            "explanation": "ビジネス要件（RTO・RPO）に応じて、復旧戦略をスケール分けします。要件が厳しいほど、冗長度・実装コストが増加します。経営判断として、許容できるダウンタイム・データ喪失を定義し、そに応じた戦略を選択します。"
        },
        {
            "id": "sa_security_059",
            "question": "サーバーのハードニング（セキュリティ強化）において、『不要なサービス・プロトコルの無効化』を実施する最主な目的はどれか。",
            "choices": [
                "サーバーのパフォーマンスを向上させるため",
                "攻撃の入口（attack surface）を最小化し、脆弱性悪用の可能性を低減するため",
                "ディスク容量を節約するため",
                "ライセンスコストを削減するため"
            ],
            "answer": 1,
            "explanation": "攻撃面（Attack Surface）が広いほど、脆弱性が存在する可能性が高まります。各サーバーの目的に応じて、不要なポート・サービス・プロトコルを最小権限原則に基づいて無効化することで、脅威にさらされる面を限定します。"
        },
        {
            "id": "sa_security_060",
            "question": "パスワード管理ポリシーの設計において、『パスワード有効期限の設定』が現在再評価されている理由として最も適切なものはどれか。",
            "choices": [
                "有効期限があるパスワードほど安全である",
                "定期変更は利便性低下・書き込み行動を招き、実際には悪化する可能性があり、強度と複雑さを優先する方が有効",
                "パスワード変更システムのコスト削減が目的",
                "定期変更すれば侵害から完全に保護される"
            ],
            "answer": 1,
            "explanation": "NIST等の最新ガイドでは『短周期の定期変更は廃止し、強力で複雑なパスワード＋多要素認証』を推奨しています。定期変更は『パターン化されたパスワード』や『紙への書き込み』につながり、むしろ脆弱性が増す傾向が報告されています。"
        },
        {
            "id": "sa_security_061",
            "question": "クラウド間のデータ移行設計において、『ベンダーロックイン』を回避するための最も有効なアプローチはどれか。",
            "choices": [
                "クラウドベンダー固有のサービスを最大限活用する",
                "標準フォーマット・オープンインターフェース（例：Kubernetes、標準SQL）を採用し、移行可能性を確保する",
                "複数クラウドは管理負担が増すため、単一ベンダーに統一する",
                "移行後は二度と移行しないと決める"
            ],
            "answer": 1,
            "explanation": "ベンダー独自サービスへの依存深化は、後の乗り換えが極めて困難になります。Kubernetes等のコンテナ標準化、ポータブルなアーキテクチャを意識して設計することで、将来の選択肢を保持できます。マルチクラウド対応も可能になります。"
        },
        {
            "id": "sa_security_062",
            "question": "アイデンティティ検証（Identity Verification）とアクセス認可（Access Authorization）の関係について、最も適切な説明はどれか。",
            "choices": [
                "同じ意味で、区別する必要はない",
                "検証は『本人確認』、認可は『本人が何をできるか』であり、両方が必要",
                "認可があれば、検証は不要",
                "検証のみで十分会"
            ],
            "answer": 1,
            "explanation": "IAM では『Authentication（認証：本人確認）』と『Authorization（認可：権限確認）』は異なるステップです。本人であることが確認されても、その人物に実行権限がなければアクセス拒否されます。両ステップの連鎖により、セキュアなアクセス制御が実現します。"
        },
        {
            "id": "sa_security_063",
            "question": "脅威インテリジェンス（Threat Intelligence）の活用において、『ホワイトリスト・ブラックリスト管理』の課題として最も重要なものはどれか。",
            "choices": [
                "リストが小さいほど管理が容易",
                "リストの更新遅延により既知の悪意あるIPやドメインを検出漏れしたり、削除済みの脅威に対応し続ける非効率が発生",
                "リストが大きいほど、すべての脅威をカバーできる",
                "手動のみで管理が最も正確である"
            ],
            "answer": 1,
            "explanation": "脅威ランドスケープは日々変化し、静的なブラックリストは陳腐化します。脅威インテリジェンスフィードの自動統合、リアルタイム更新、複数ソースの相関分析により、動的に脅威対応する必要があります。"
        },
        {
            "id": "sa_security_064",
            "question": "コンテナセキュリティにおいて『イメージの層（レイヤー）』の管理が重要な理由として最も適切なものはどれか。",
            "choices": [
                "レイヤー数を最小化すればセキュリティが向上する",
                "各レイヤーは独立で検査・署名でき、イメージの供給チェーン管理と改ざん検知が可能",
                "レイヤーの存在はセキュリティと無関係",
                "すべてのレイヤーで同じパーミッションを設定すべき"
            ],
            "answer": 1,
            "explanation": "コンテナイメージは重層構造であり、各レイヤーは独立で署名・検証・スキャン可能です。これにより、イメージの履歴追跡、改ざん検知、供給チェーン攻撃対抗が実現できます。コンテナレジストリと組み合わせて、セキュアなデプロイが可能です。"
        },
        {
            "id": "sa_security_065",
            "question": "APIゲートウェイでのレート制限実装において、『分散アーキテクチャ下での状態共有』が課題である理由として最も適切なものはどれか。",
            "choices": [
                "単一サーバーで十分であるため、分散は不要",
                "複数ゲートウェイが各自でカウントすると、全体制限を超える可能性があり、分散ロック・共有状態が必須",
                "分散ではレート制限は実装不可能",
                "状態共有はパフォーマンス低下をもたらすため実装すべきでない"
            ],
            "answer": 1,
            "explanation": "水平スケーリングでマルチゲートウェイ構成時、各ゲートウェイが独立してレート制限をカウントすると、全体での過度なトラフィック通過が起こります。Redis等の共有状態ストアにより、グローバルなレート制限を実装する必要があります。"
        },
        {
            "id": "sa_security_066",
            "question": "IoTデバイスのセキュリティ設計における『ファームウェア更新メカニズム』の重要性として最も適切なものはどれか。",
            "choices": [
                "ファームウェア更新は不要で、初期バージョンで十分",
                "脆弱性発見時の継続的な修正、セキュリティパッチの段階的配信、更新の署名検証により、デバイスライフサイクル全体での保護が可能",
                "更新はリスクが高いため実施すべきでない",
                "更新は完全自動化すべきで、ユーザー確認は不要"
            ],
            "answer": 1,
            "explanation": "IoT デバイスは年単位で運用され、その間新しい脆弱性が発見されます。安全な更新メカニズム（署名検証、ロールバック対応）がなければ、デバイスは脆弱性にさらされ続けます。OTA（Over-The-Air）アップデートとその検証は必須です。"
        },
        {
            "id": "sa_security_067",
            "question": "グローバルかつ多言語対応システムのセキュリティ設計において、『文字エンコーディングの脆弱性』への対策として最も重要なものはどれか。",
            "choices": [
                "すべての入力をASCIIに限定する",
                "UTF-8等の標準エンコーディング採用、入力正規化、バイト列レベルの検証により、エンコーディング攻撃（Overlong UTF-8等）を防止する",
                "複数のエンコーディングをサポートすればセキュリティが向上する",
                "エンコーディング変換はセキュリティと無関係"
            ],
            "answer": 1,
            "explanation": "UTF-8の Overlong エンコード等の不正エンコーディングは、バリデーション・ファイアウォールを迂回する手法です。入力クリーニング時に正規化・正当性チェック、バイト列レベルでの検証を実施することで、エンコーディング攻撃を防止できます。"
        },
        {
            "id": "sa_security_068",
            "question": "セキュリティインシデント後の『根本原因分析（RCA）』における最も重要な実施項目はどれか。",
            "choices": [
                "責任者を特定し、懲罰することのみ",
                "『なぜなぜ分析』により複数の根本原因を探索し、再発防止策を設計・実装する",
                "外部への報告を優先する",
                "RCA と無関係に新たな対策を導入する"
            ],
            "answer": 1,
            "explanation": "根本原因分析は『懲罰』ではなく『改善』が目的です。事象分析から、なぜそれが起きたのか層的に掘り下げ（なぜなぜ分析）、システム・プロセス・組織の根本原因に到達し、再発防止策を設計します。これが継続的セキュリティ向上の鍵です。"
        },
        {
            "id": "sa_security_069",
            "question": "クラウドストレージのアクセス制御設計において『デフォルトで非公開』の原則が重要な理由として最も適切なものはどれか。",
            "choices": [
                "デフォルト公開の方が管理が簡単",
                "設定ミスにより機密データが誤公開される事故を防ぎ、必要時にのみ公開権限を付与する",
                "クラウドストレージは本来公開を想定している",
                "アクセス権限管理は不要"
            ],
            "answer": 1,
            "explanation": "クラウドストレージサービスの設定ミス（機密データの公開 S3 バケット等）は、データ漏洩の主要な原因です。デフォルトで非公開にし、必要に応じて制限付きアクセス権を付与する『ホワイトリスト型』設定により、人為ミスによる波及を最小化できます。"
        },
        {
            "id": "sa_security_070",
            "question": "エンタープライズ環境でのシャドー IT 対策として最も有効なアプローチはどれか。",
            "choices": [
                "すべてのクラウドサービス利用を禁止する",
                "エンドユーザーのニーズを持つ認可チャネル（例：クラウドマーケットプレイス）を提供し、利用を可視化・統制する",
                "利用実態を知らず、後で知った時に処処置する",
                "セキュリティ部門で承認されたサービスのみの公式サポートで対応する"
            ],
            "answer": 1,
            "explanation": "シャドー IT（ IT管理外の利用）は、利用者のユーザビリティニーズに応えるための現象です。代替として『承認されたサービスカタログ』を提供し、IT可視化ツール（CASB等）でモニタリング・統制する『可視化と許容の并行』がより実効的です。"
        },
        {
            "id": "sa_security_071",
            "question": "セキュアなAPIゲートウェイ設計における『OpenAPI スキーマ駆動開発』の利点として最も適切なものはどれか。",
            "choices": [
                "開発速度のみが向上する",
                "スキーマに基づく自動検証、セキュリティテスト生成、クライアント/サーバー間のコントラクト仕様により、セキュリティと相互運用性が向上",
                "セキュリティには関連がない",
                "スキーマ管理が負担になるだけ"
            ],
            "answer": 1,
            "explanation": "OpenAPI 仕様はドキュメント以上の役割があります。スキーマベースの入力検証、自動セキュリティテスト（Swagger UI から直接テスト可能）、クライアント・サーバー間の明確なコントラクト定義により、脆弱性を設計段階で防止できます。"
        },
        {
            "id": "sa_security_072",
            "question": "データベース暗号化の導入に際して、『パフォーマンス影響の評価』が重要な理由として最も適切なものはどれか。",
            "choices": [
                "暗号化はパフォーマンス低下しないため無視してよい",
                "暗号化は CPU 負荷・I/O レイテンシを増加させダウンタイムにつながるため、SLA目標との両立を確認する",
                "パフォーマンス問題があっても、暗号化を優先すべき",
                "データベースハードウェアの性能だけでパフォーマンスが決まる"
            ],
            "answer": 1,
            "explanation": "データベース暗号化は CPU 集約的で、複雑なクエリや大量読み込みでレイテンシが増加することがあります。導入前にベンチマークテストを実施し、オフロード（FPGA/GPU）や暗号化カラムの選別により、SLA との両立を図る必要があります。"
        },
        {
            "id": "sa_security_073",
            "question": "Zero Trust Architecture（ZTA）実装における『継続的な検証』が意味することとして最も適切なものはどれか。",
            "choices": [
                "初回認証のみで、以降は信頼する",
                "ユーザー・デバイス・トラフィックの正当性を継続的に再検証し、異常時は即座にアクセス遮断する",
                "検証は初期化時のみで十分",
                "検証により全セキュリティ脅威をゼロにできる"
            ],
            "answer": 1,
            "explanation": "ZTA では『信頼はデフォルトではなく、アクセス毎に検証』します。認証後も、端末の正常性（MDM ポリシー遵守）、行動（通常と異なる操作）、位置情報等を継続監視し、異常検知時は即座にセッション中断します。"
        },
        {
            "id": "sa_security_074",
            "question": "ソフトウェア開発での『セキュアコーディング教育』が重要な理由として最も適切なものはどれか。",
            "choices": [
                "開発者は本来セキュリティに関心がないため不要",
                "開発者がセキュリティ脆弱性の代表的パターンを認識していることで、設計・実装段階での脆弱性導入を削減できる",
                "セキュリティツールのみで脆弱性は検知できる",
                "教育のコストが高いため省く"
            ],
            "answer": 1,
            "explanation": "セキュアコーディング教育により、OWASP Top 10等の脆弱性パターンをコードレビュー段階で検知できます。自動ツールでは検知困難なロジック脆弱性（認可漏れ等）も人間の目で検出でき、修正コストが低減します。"
        },
        {
            "id": "sa_security_075",
            "question": "ビジネス部門とのセキュリティ方針協議において『リスク受容の判断』が必要とされるのはなぜか。",
            "choices": [
                "すべてのセキュリティ対策を無条件に実装すべき",
                "セキュリティコストと事業価値のバランスを考慮し、許容可能なリスクレベルを組織で決定する必要がある",
                "セキュリティ部門が独断で決定すべき",
                "リスク受容は経営判断と無関係"
            ],
            "answer": 1,
            "explanation": "セキュリティ対策には常にコストがあり、100% のセキュリティは実現不可能です。組織のビジネス目標、予算制約を考慮し、『このリスクレベルは許容する』という経営判断がなければ、実効的なセキュリティ方針にはなりません。"
        },
        {
            "id": "sa_security_076",
            "question": "プロトコルレイヤーセキュリティ（例：IPSec、TLS）とアプリケーションレイヤーセキュリティの関係として最も適切なものはどれか。",
            "choices": [
                "どちらか一方で十分",
                "それぞれが異なる脅威に対応し、多層防御のため両方の実装が必要",
                "プロトコルレイヤーのみで全セキュリティが実現される",
                "アプリケーションレイヤーセキュリティはプロトコルに含まれるため不要"
            ],
            "answer": 1,
            "explanation": "プロトコルレイヤーセキュリティは通信チャネル保護（盗聴、改ざん防止）を、アプリケーションレイヤーセキュリティはアプリケーションロジックの脆弱性（SQLインジェクション等）を対象とします。完全な保護には両者が必要で、いずれか一つの突破で侵害される可能性があります。"
        },
        {
            "id": "sa_security_077",
            "question": "脅威モデリング（Threat Modeling）を実施する最大のメリットとして最も適切なものはどれか。",
            "choices": [
                "すべての脅威を完全に排除できる",
                "設計段階で予見可能な脅威を列挙・評価し、対策優先度を決定、セキュアな設計へ反映させられる",
                "脅威モデリングは後付け対策より効果的",
                "セキュリティツールのみで脅威を検知できるため不要"
            ],
            "answer": 1,
            "explanation": "脅威モデリング（例：STRIDE）は設計段階での脅威を体系的に列挙し、対策の漏れを防止します。実装後の脆弱性修正は数倍以上のコストがかかるため、早期の脅威同定が重要です。"
        },
        {
            "id": "sa_security_078",
            "question": "コンテナオーケストレーション（Kubernetes）環境でのロールアウト・ロールバック機構の安全性として最も関連性が高いのはどれか。",
            "choices": [
                "新バージョンをのみ展開し、ロールバックは不要",
                "段階的展開（カナリア/ブルーグリーン）、自動ヘルスチェック、迅速なロールバックにより、脆弱なバージョンのクイック復旧が可能",
                "一括置き換えにより最速でデプロイする",
                "ロールバック機能はセキュリティと無関係"
            ],
            "answer": 1,
            "explanation": "セキュリティパッチデプロイ時に新バージョンに脆弱性が存在する場合、カナリア展開による早期検知、クイックロールバックにより被害を最小化できます。これは本番環境の継続的な可用性とセキュリティの両立に重要です。"
        },
        {
            "id": "sa_security_079",
            "question": "ログ中央集約システム（SIEM）でのログ正規化が重要な理由として最も適切なものはどれか。",
            "choices": [
                "ログのファイルサイズ削減のみ",
                "異なるフォーマットのログを統一形式に変換することで、自動相関分析・検索・アラートが可能",
                "正規化により検索精度が低下する",
                "ログの詳細情報は正規化で失われるため、元フォーマット保持が重要"
            ],
            "answer": 1,
            "explanation": "複数システムのログは異なるフォーマット（タイムスタンプ形式、情報項目等）を持ちます。正規化により『ユーザー ID が一貫性を持った』相関分析が可能になり、複数段階の攻撃検知（ユーザー A がログイン→特定ファイルアクセス→データ抜き出し）が可能になります。"
        },
        {
            "id": "sa_security_080",
            "question": "AIを用いたセキュリティシステムの『敵対的攻撃（Adversarial Attack）』への対抗策として最も重要なものはどれか。",
            "choices": [
                "AI システムは本質的に安全であり、対抗策は不要",
                "AI のロバストネステスト（異常な入力への耐性試験）、複数モデルの組み合わせ、ホワイトボックス検証により、敵対的攻撃への耐性を強化する",
                "AI に対する攻撃検知は不可能",
                "敵対的攻撃の影響は無視できる"
            ],
            "answer": 1,
            "explanation": "AI モデルは微細な入力変更（ピクセル微調整等）により分類を誤ります。セキュリティ用 AI には、敵対的サンプルへのロバストネステスト、複数モデルアンサンブル、入力検証を組み込み、耐性を強化する必要があります。これは AI セキュリティの新領域です。"
        },
        {
            "id": "sa_security_081",
            "question": "古いシステムのセキュリティ維持（Legacy システムの保護）において実現困難な環境での対策として最も実用的なものはどれか。",
            "choices": [
                "古いシステムは放置し、新対商品への置き換えを待つ",
                "WAF・IDS/IPS等の外層防御、仮想化によるネットワークしagementation、サポートされたOS での実行環境提供、定期的な脆弱性スキャンで層的に対応",
                "セキュリティパッチ適用のみで十分",
                "古いシステムはセキュリティ対策が不可能"
            ],
            "answer": 1,
            "explanation": "レガシーシステムはベンダーサポート終了、パッチ不可能な場合があります。外層での防御（WAF・IDS）、ネットワーク隔離、交換環境での保護により、脆弱性を露出させない『防御』アプローチが現実的です。"
        },
        {
            "id": "sa_security_082",
            "question": "分散型システムでの『コンセンサスメカニズムのセキュリティ』が重要な理由として最も適切なものはどれか。",
            "choices": [
                "コンセンサスはシステムパフォーマンスにのみ影響する",
                "共通の状態合意の仕組みが損なわれると、二重支払い・改ざん・リプレイ攻撃が可能になるため、暗号学的に安全な仕組みが必須",
                "ブロックチェーンではコンセンサスは不要",
                "コンセンサスアルゴリズムはセキュリティと無関係"
            ],
            "answer": 1,
            "explanation": "ブロックチェーン等の分散システムでは、複数ノードが同じ台帳状態に合意するコンセンサスプロセスが信頼の基盤です。このメカニズムが弱いと、攻撃者が監査役過多派（51% attack等）により不正な状態を承認させられ、金銭損失が発生します。"
        },
        {
            "id": "sa_security_083",
            "question": "監査ログの『削除不可（Write Once Read Many=WORM）設定』が重要な理由として最も適切なものはどれか。",
            "choices": [
                "管理者はログを編集・削除できるべき",
                "攻撃者による証拠隠滅（ログ削除）を物理的に防止し、事後調査・訴訟での証拠能力を保加する",
                "WORM は運用負荷が増すため避けるべき",
                "ログの信頼性はセキュリティと別問題"
            ],
            "answer": 1,
            "explanation": "侵害者の目標の一つは『証拠隠滅』です。WORM により、管理者権限でもログ改ざん・削除を禁止しておくことで、事後のフォレンジック調査・訴訟での使用が可能になります。S3 Object Lock 等で実装可能です。"
        },
        {
            "id": "sa_security_084",
            "question": "セキュリティメトリクスの『KPI化』において最も重要な要素はどれか。",
            "choices": [
                "高い数値を目指すだけ",
                "測定可能性、信頼性、ビジネス目標との関連性を持つメトリクスを選定し、組織全体のセキュリティ成熟度向上に連動させる",
                "セキュリティメトリクスは定量化不可能",
                "管理者の好みで自由に選定"
            ],
            "answer": 1,
            "explanation": "有効な KPI は『測定可能（脆弱性検出率）』『意味がある（攻撃検知時間短縮）』『ビジネス連動（セキュリティインシデント損失削減）』である必要があります。虚無的な数値目標は組織をミスリードするため、慎重に設計すべきです。"
        },
        {
            "id": "sa_security_085",
            "question": "セキュリティ監が機械学習の『モデルドリフト（Model Drift）』により影響を受ける理由として最も適切なものはどれか。",
            "choices": [
                "モデルドリフトはセキュリティと無関係",
                "学習データ・攻撃パターンの時時的変化により、モデルの検知精度が経時劣化し、脅威見逃しが増加する",
                "モデルドリフトは悪い現象ではない",
                "継続的再学習で永遠に精度が向上する"
            ],
            "answer": 1,
            "explanation": "悪意あるまたは正常な行動パターンは時間とともに変化します。学習済みモデルが古い分布を前提としていると、新パターンの脅威を見逃します。定期的な再学習、検知精度の監視、継続的改善が必要です。"
        },
        {
            "id": "sa_security_086",
            "question": "ゼロトラストの『絶えずの検証』実装における『デバイスヘルスチェック』の役割として最も適切なものはどれか。",
            "choices": [
                "機械的なハードウェア診断のみ",
                "企業セキュリティポリシー（ファイアウォール有効、ウイルス対策最新版。OS パッチ最新）への準拠を確認し、ポリシー違反デバイスのアクセス制限",
                "ヘルスチェックはセキュリティと無関係",
                "すべてのデバイスは信頼できると見なす"
            ],
            "answer": 1,
            "explanation": "デバイスが企業ポリシーに準拠しなくなった場合（古い OS パッチ、無効なウイルス対策）、アクセス権を制限し、修復後に復旧する仕組みが必要です。これが『継続的検証』の一部で、ゼロトラストの実装を支える重要な要素です。"
        },
        {
            "id": "sa_security_087",
            "question": "セキュリティアーキテクチャの『再利用可能性（Reusability）』が重要な理由として最も適切なものはどれか。",
            "choices": [
                "冗長設計を避けるため",
                "複数プロジェクトに応用可能なセキュリティパターン・ライブラリを構築することで、一貫したセキュリティ対応・開発効率化が実現",
                "セキュリティは個別プロジェクト毎に設計すべき",
                "再利用性によりセキュリティリスクが増加する"
            ],
            "answer": 1,
            "explanation": "OAuth対統合認証、WAF ルールセット等の『セキュリティテンプレート』を組織で再利用すれば、一貫した保護水準を保ちながら、各プロジェクトの開発効率化が実現します。組織成熟度向上の鍵です。"
        },
        {
            "id": "sa_security_088",
            "question": "セキュアな「開発・テスト・本番」環境（DevOps）の分離において最も重要な考慮点はどれか。",
            "choices": [
                "開発・テスト・本番は全く同じ環境で構築すべき",
                "本番環境は最も厳密なアクセス制御・監査を実施し、開発の利便性と分離・監視のバランスを取る",
                "開発環境に本番データを使用してよい",
                "環境分離はセキュリティと無関係"
            ],
            "answer": 1,
            "explanation": "開発・テスト環境では開発効率のため制限を緩める必要がありますが、本番環境では最高レベルの統制が必須です。アクセス人員、操作権限、データ、変更プロセスを厳密に分離することで、開発の過誤が本番に波及するリスクを低減します。"
        },
        {
            "id": "sa_security_089",
            "question": "『セキュリティ債（Security Debt）』の概念が重要とされる理由として最も適切なものはどれか。",
            "choices": [
                "セキュリティ債は無視してかまわない",
                "初期段階でセキュリティ実装を後延後棋にしたツケは、後の修正コスト大幅増加として現れるため、初期投資の重要性",
                "セキュリティは本番後でのみ実装すべき",
                "セキュリティ債は存在しない"
            ],
            "answer": 1,
            "explanation": "財務債と同様、セキュリティ債も累積し、利息（追加対応コスト）が増加します。脆弱な設計の後付け修正は、大規模な再設計が必要になり、莫大なコスト・遅延が発生します。初期設計段階での投資が最も効率的です。"
        },
        {
            "id": "sa_security_090",
            "question": "適応的セキュリティ（Adaptive Security）の実装において『脅威情報の活用』が重要な理由として最も適切なものはどれか。",
            "choices": [
                "脅威情報は参考情報に過ぎず、優先度決定に使わない",
                "組織を狙う現在の脅威トレンド、既知の攻撃手法を反映した対策を段階的に調整し、効率的な防御を実現",
                "脅威情報の収集は管理負担が大きい",
                "固定ポリシーはセキュリティと同等に有効"
            ],
            "answer": 1,
            "explanation": "セキュリティランドスケープは日々変化し、当初有効な対策も時間とともに陳腐化します。脅威インテリジェンス（TTPs、新しい CVE 等）を監視し、対策を動的に調整する『適応的防御』が現代的なセキュリティアプローチです。"
        },
        {
            "id": "sa_security_091",
            "question": "セキュリティアーキテクチャの『将来進化性（Future-Proofing）』が重要な理由として最も適切なものはどれか。",
            "choices": [
                "現在のセキュリティテクノロジーで十分",
                "新しい脅威・規制・テクノロジーへの対応を容易にする設計（モジュール化、標準インターフェース）により、長期的な投資保護",
                "将来は予測不可能であるため設計も不要",
                "アーキテクチャ変更は費用がかかるため、固定設計を永遠に使用"
            ],
            "answer": 1,
            "explanation": "システムは通常数年以上運用されます。AI脅威、新規制への対応等、後発する要件が必ず出現します。設計段階で拡張性・交換可能性を確保しておくことで、後の適応コストを低減できます。"
        },
        {
            "id": "sa_security_092",
            "question": "ブロックチェーン活用システムにおけるスマートコントラクトのセキュリティ検証として最も重要なものはどれか。",
            "choices": [
                "スマートコントラクトはコンパイルされているため安全",
                "ロジック脆弱性（リエントランシー等）への検証、形式検証、監査を実施し、不可逆な実行リスクに対応",
                "スマートコントラクトは本質的に安全",
                "セキュリティ検査は不要"
            ],
            "answer": 1,
            "explanation": "スマートコントラクトは自動実行され、漏洞があれば即座に資産喪失につながります。複数の脆弱性パターン（リエントランシー、整数オーバーフロー等）に対する検証、形式検証により、デプロイ前の欠陥排除が必須です。"
        },
        {
            "id": "sa_security_093",
            "question": "セキュアデリバリーのパイプライン（CI/CD）で『品質ゲート（Quality Gate）』を設定する目的として最も適切なものはどれか。",
            "choices": [
                "デプロイを遅延させるため",
                "セキュリティ要件・コード品質基準を満たさないコードの本番デプロイを自動的にブロック",
                "品質ゲートはセキュリティと無関係",
                "本番環境での修正で対応可能"
            ],
            "answer": 1,
            "explanation": "品質ゲート（脆弱性スコアが一定以下、テストカバレッジが基準以上）を CI/CD パイプラインに組込むことで、欠陥コードの本番デプロイを自動防止できます。これが DevSecOps の核となる実践です。"
        },
        {
            "id": "sa_security_094",
            "question": "エンドツーエンド暗号化（E2EE）実装時の『鍵交換の安全性』が重要な理由として最も適切なものはどれか。",
            "choices": [
                "鍵交換はセキュリティと無関係",
                "通信相手と秘密鍵を安全に共有するメカニズム（ディフィ・ヘルマン等）が破綻すると、E2EE 全体が無意味になる",
                "鍵交換は公開チャネルで実施してよい",
                "鍵交換の複雑さ低減が最優先"
            ],
            "answer": 1,
            "explanation": "E2EE では『鍵交換の安全性』が全体のセキュリティ基盤です。中間者攻撃により鍵が盗聴・改ざんされれば、その後の暗号化通信は無意味です。楕円曲線暗号等の鍵交換アルゴリズムは、暗号化アルゴリズム同様に重要です。"
        },
        {
            "id": "sa_security_095",
            "question": "セキュリティ監査にあたり『監査人の独立性（Independence）』が重要な理由として最も適切なものはどれか。",
            "choices": [
                "独立性は不要で、利害者による監査も有効",
                "被監査部門からの独立が保証されることで、公平性・信頼性のある監査結果が得られ、経営層の意思決定に活用される",
                "完全独立は不可能であるため監査は信用できない",
                "内部監査は独立性が必須で、外部監査は不要"
            ],
            "answer": 1,
            "explanation": "内部監査であっても、経営層直属・人事評価に被監査部門が関与しない等の独立性が必要です。利害関係者による監査は『身内に甘い』結果になりやすく、実効的な改善につながりません。"
        },
        {
            "id": "sa_security_096",
            "question": "クラウド環境での『責任共有モデル』理解においての最も重要なポイントはどれか。",
            "choices": [
                "セキュリティ責任は全てクラウドベンダーにある",
                "インフラのセキュリティはベンダー、アプリケーション・データのセキュリティはユーザー側で、明確な責任分界を理解する",
                "ユーザー側は全責任を負う",
                "責任分界は固定的で、柔軟でない"
            ],
            "answer": 1,
            "explanation": "AWS/Azure 等は『責任共有モデル』を明確にしています。ユーザー側がアプリケーション脆弱性・アクセス制御に責任を持つにもかかわらず、『ベンダー任せ』と勘違いして侵害される事例が少なくありません。"
        },
        {
            "id": "sa_security_097",
            "question": "セキュリティ可視化（Security Visualization）が重要とされる理由として最も適切なものはどれか。",
            "choices": [
                "ダッシュボード表示が目的",
                "複雑なセキュリティイベント・ネットワークトポロジを図表化することで、経営層を含む利害者が脅威・対策を直感的に理解できる",
                "可視化はコスト増加のため不要",
                "文字情報のみで十分"
            ],
            "answer": 1,
            "explanation": "セキュリティ metrics の多数の数値データは、意思決定層には難解です。視化により『何が重要か』『どこが脆弱か』が一目瞭然になり、経営判断・予算配分の質が向上します。"
        },
        {
            "id": "sa_security_098",
            "question": "セキュリティ標準化（Security Standardization）の組織への効果として最も適切なものはどれか。",
            "choices": [
                "標準化により革新性が失われる",
                "共通の秉風・フレームワーク（例：NIST CSF）採用により、組織全体の一貫したセキュリティ水準を確保し、コンプライアンス対応も容易になる",
                "標準化は不要で、各部門独立で対応",
                "標準に従う義務はない"
            ],
            "answer": 1,
            "explanation": "組織内でセキュリティ標準を定義・適用することで、部門間のギャップを埋め、監査・コンプライアンス対応が効率化します。同時に、ベストプラクティス共有により、組織全体の成熟度が向上します。"
        },
        {
            "id": "sa_security_099",
            "question": "セキュリティに対する『組織文化（Security Culture）』構築が重要な理由として最も適切なものはどれか。",
            "choices": [
                "技術対策のみでセキュリティは実現される",
                "全従業員がセキュリティを『自分事』と見なし、無意識のうちに安全な行動を取ることで、人為ミス・内部脅威を削減",
                "従業員教育は費用対効果が悪い",
                "セキュリティ専門チームのみがセキュリティを担当すべき"
            ],
            "answer": 1,
            "explanation": "セキュリティは『技術 + 組織 + 人間』の三要素で成り立ちます。全従業員がセキュリティ意識を持つ文化があれば、フィッシング詐欺への気づき、無意識のパスワード漏洩等の人為ミスが大幅に削減されます。"
        },
        {
            "id": "sa_security_100",
            "question": "セキュアアーキテクチャの『継続的改善サイクル』実装において最も重要な要素はどれか。",
            "choices": [
                "一度設計したら永遠に変更しない",
                "Plan-Do-Check-Act（PDCA）サイクルにより、脅威、規制、テクノロジーの変化に応じてセキュリティアーキテクチャを段階的に進化させる",
                "改善は不要で、現状維持で十分",
                "改善判断は経営層を除いて行う"
            ],
            "answer": 1,
            "explanation": "セキュリティランドスケープは絶えず変化します。定期的な脅威評価、セキュリティ成熟度診断、新規テクノロジー導入検討により、アーキテクチャを継続的に進化させることが、長期的な有効性を確保します。"
        }
    ],
    "java_generics_lambda": [
        {
            "id": "java_generics_lambda_051",
            "question": "ジェネリクスでの『ワイルドカード型パラメータ（? extends/super）』の使用場面として最も適切なものはどれか。",
            "choices": [
                "すべてのジェネリック型で使用すべき",
                "メソッドパラメータで型安全性と柔軟性のバランスを取り、共変性（extends）/反変性（super）を制御する",
                "ワイルドカードは読み取り専用",
                "型キャスト時のみ使用可能"
            ],
            "answer": 1,
            "explanation": "ワイルドカードは『型の曖昧性』を意図的に導入し、メソッドの汎用性を高めます。List<? extends Number> は Number のサブクラスのリストを受け入れ、List<? super Integer> は Integer の親クラスのリストに値を追加できます。"
        },
        {
            "id": "java_generics_lambda_052",
            "question": "ラムダ式での『関数型インターフェース（Functional Interface）』の定義として最も適切なものはどれか。",
            "choices": [
                "複数の抽象メソッドを持つインターフェース",
                "ただ1つの抽象メソッドを持つインターフェース。ラムダ式はこの単一メソッドの実装を簡潔に表現",
                "デフォルトメソッドのみのインターフェース",
                "ラムダ式と関数型インターフェースは無関係"
            ],
            "answer": 1,
            "explanation": "@FunctionalInterface アノテーションで宣言された関数型インターフェースは、ラムダ式による実装が可能です。これにより、動名詞的なコードが記述可能になります。"
        },
        {
            "id": "java_generics_lambda_053",
            "question": "型消去（Type Erasure）がジェネリクスの実行時に引き起こす制限として最も適切なものはどれか。",
            "choices": [
                "実行時性能が向上する",
                "ジェネリック型情報はコンパイル時のみで、実行時には消去される（例：List<Integer> は List になる）",
                "型消去により型安全性は完全に保証される",
                "型消去は Java 固有ではなく全言語で発生"
            ],
            "answer": 1,
            "explanation": "Java の型消化はバイナリ互換性を保つための設計ですが、instanceof や new T[] 等が不可能になります。リフレクション時にジェネリック型情報にアクセスできず、実行時型チェックが限定的です。"
        },
        {
            "id": "java_generics_lambda_054",
            "question": "メソッド参照（Method Reference）とラムダ式の関係について最も適切な説明はどれか。",
            "choices": [
                "メソッド参照とラムダ式は全く別の概念",
                "メソッド参照はラムダ式のシンタックスシュガーで、既存メソッドをより簡潔に参照する",
                "メソッド参照は古い書き方で、ラムダ式が唯一の方法",
                "メソッド参照は実行時パフォーマンスが低下"
            ],
            "answer": 1,
            "explanation": "list.forEach(System.out::println) はラムダ式 list.forEach(x -> System.out.println(x)) の簡潔版です。メソッド参照により可読性が向上します。"
        },
        {
            "id": "java_generics_lambda_055",
            "question": "ジェネリック型での『共変性（Covariance）』を実装するための適切な方法はどれか。",
            "choices": [
                "型パラメータに制限を設けない",
                "? extends キーワードで上限境界を設定し、サブクラスを許容する",
                "共変性は Java で実装不可能",
                "原始型（Raw Type）を使用する"
            ],
            "answer": 1,
            "explanation": "List<? extends Animal> は Animal またはそのサブクラスのリストを受け入れ、共変性を実現します。これにより、List<Dog> を List<? extends Animal> として渡せます。"
        },
        {
            "id": "java_generics_lambda_056",
            "question": "ラムダ式での『キャプチャ変数（Captured Variables）』に関する制限として最も適切なものはどれか。",
            "choices": [
                "キャプチャ変数に制限はない",
                "外側スコープの変数をキャプチャする場合、実質的に final である必要がある（値が変わらない）",
                "すべてのキャプチャ変数は mutable である",
                "ラムダ式は外側の変数にアクセスできない"
            ],
            "answer": 1,
            "explanation": "Java ラムダ式は『effective final』の制限があり、キャプチャされた変数が暗黙的に final 扱いになります。これにより、並行実行時の予測不可能な動作を防ぎます。"
        },
        {
            "id": "java_generics_lambda_057",
            "question": "多重型パラメータ（Multiple Type Parameters）を持つクラス定義として最も適切なものはどれか。",
            "choices": [
                "複数の型パラメータは使用できない",
                "public class Pair<K, V> { } のように複数パラメータを定義し、独立した型制約を各パラメータに設定可能",
                "複数型パラメータは継承でのみ使用可能",
                "型パラメータは1つのみ推奨"
            ],
            "answer": 1,
            "explanation": "Map<K, V> のように複数の独立した型パラメータを持つジェネリククラスが可能です。各パラメータに異なる境界制約を設定できます。"
        },
        {
            "id": "java_generics_lambda_058",
            "question": "ジェネリック内のジェネリック（Nested Generics）使用時の複雑さ軽減方法として最も適切なものはどれか。",
            "choices": [
                "ネストされたジェネリクスは避けるべき",
                "型エイリアス（TypeAlias）やメソッドの型パラメータへの変数導入により、複雑な型シグネチャを簡潔化",
                "原始型（Raw Type）を強要する",
                "ネストは Java で未対応"
            ],
            "answer": 1,
            "explanation": "Map<String, List<Integer>> は複雑です。メソッドで型パラメータを導入すると、シグネチャが簡潔になります。"
        },
        {
            "id": "java_generics_lambda_059",
            "question": "Stream API とラムダ式の組み合わせにより実現される利点として最も適切なものはどれか。",
            "choices": [
                "実行性能のみ向上",
                "宣言的記述（map/filter 等）により、命令型コードより可読性・保守性が向上。並列処理も容易",
                "Stream はメモリ効率が悪い",
                "Stream API とラムダ式は関連がない"
            ],
            "answer": 1,
            "explanation": "list.stream().filter(x -> x > 10).map(x -> x * 2).collect(Collectors.toList()) は命令型ループより直感的です。parallelStream() で並列化も容易です。"
        },
        {
            "id": "java_generics_lambda_060",
            "question": "型安全性とジェネリクスの関係について最も適切な説明はどれか。",
            "choices": [
                "ジェネリクスは型安全性と無関係",
                "ジェネリクスにより『型チェック不一致（ClassCastException）』をコンパイル段階で検出でき、実行時エラー削減",
                "ジェネリクスがあってもキャストは必須",
                "型安全性はフレームワークレベルで実現される"
            ],
            "answer": 1,
            "explanation": "List<String> は String 要素のみを許容し、Integer を追加しようとするとコンパイルエラーになります。実行時 ClassCastException から保護されます。"
        }
    ],
    "java_concurrency": [
        {
            "id": "java_concurrency_051",
            "question": "マルチスレッド環境での『メモリ可視性（Memory Visibility）』の問題として最も適切なものはどれか。",
            "choices": [
                "スレッド間のメモリアクセスは同期される",
                "あるスレッドの变数変更が、他スレッドで即座に見えない可能性があり、volatile キーワードや synchronization で対応",
                "メモリ可視性は Java では保証されている",
                "CPU キャッシュの存在はパフォーマンスと無関係"
            ],
            "answer": 1,
            "explanation": "volatile キーワードは『変更を全スレッドに即座に可視化』する仕組みです。volatile なしでは、あるスレッドの変数変更が他スレッドで遅延・未検知される可能性があります。"
        },
        {
            "id": "java_concurrency_052",
            "question": "デッドロック（Deadlock）の発生条件として最も適切なものはどれか。",
            "choices": [
                "相互排除・保有と待機・非奪取・循環待機の4条件が全て満たされない",
                "相互排除・保有と待機・非奪取・循環待機の4条件が全て満たされた場合、デッドロック発生の可能性",
                "デッドロックは Java では発生しない",
                "ロック数が多いほどデッドロック可能性が低い"
            ],
            "answer": 1,
            "explanation": "スレッド A が Lock1 を保有して Lock2 を待機し、スレッド B が Lock2 を保有して Lock1 を待機する場合、4条件が満たされデッドロックします。"
        },
        {
            "id": "java_concurrency_053",
            "question": "ExecutorService を使用するメリットとして最も適切なものはどれか。",
            "choices": [
                "直接 Thread 生成と変わらない",
                "スレッドプール管理、タスクキューイング、Shutdown の段階的複雑さを隠蔽し、並行処理を簡潔化",
                "ExecutorService はシングルスレッドのみ",
                "パフォーマンス向上なし"
            ],
            "answer": 1,
            "explanation": "ExecutorService は Thread 毎の生成・破棄コスト削減、リソースリーク防止、タスク待機等を自動管理し、スレッドプール使用の典型的パターンです。"
        },
        {
            "id": "java_concurrency_054",
            "question": "ConcurrentHashMap が通常の HashMap より優れている理由として最も適切なものはどれか。",
            "choices": [
                "メモリ使用量が少ない",
                "セグメント分割ロックにより、複数スレッドからの並行読み取り・更新が効率的。全体ロックより並行度が高い",
                "ConcurrentHashMap は遅い",
                "HashMap より機能が少ない"
            ],
            "answer": 1,
            "explanation": "ConcurrentHashMap は HashMap 全体をロックせず、セグメント毎にロックすることで、複数スレッド並行アクセスの並行度を向上させます。"
        },
        {
            "id": "java_concurrency_055",
            "question": "CountDownLatch の使用場面として最も適切なものはどれか。",
            "choices": [
                "スレッド間の排他制御のみ",
                "複数スレッドがそれぞれ処理を実行し、全てのスレッドが完了するまであるスレッド・メインスレッドが待機する場面",
                "CountDownLatch は使用すべきでない",
                "単一スレッドの同期"
            ],
            "answer": 1,
            "explanation": "CountDownLatch(3) で3つのカウントダウンを設定し、各スレッド完了時に countDown()、メインスレッドは await() でブロックされ、全スレッド完了後に開放されます。"
        },
        {
            "id": "java_concurrency_056",
            "question": "BlockingQueue の特性として最も適切なものはどれか。",
            "choices": [
                "普通のキューと変わらない",
                "キューが満杯時に put() はブロック、空時に take() はブロックされ、プロデューサー・コンシューマーパターンを簡潔化",
                "BlockingQueue は put() での待機がない",
                "パフォーマンス向上が目的"
            ],
            "answer": 1,
            "explanation": "BlockingQueue はスレッド間のデータ受け渡しを効率化し、手動のロック・条件変数が不要になります。Producer-Consumer パターンの標準実装です。"
        },
        {
            "id": "java_concurrency_057",
            "question": "ReentrantLock と synchronized の相違点として最も適切なものはどれか。",
            "choices": [
                "機能は同じ",
                "ReentrantLock は try-finally での確実なアンロック、複数条件変数、フェアロックオプションが可能。多機能だが複雑",
                "ReentrantLock は遅い",
                "synchronized の方が新しい"
            ],
            "answer": 1,
            "explanation": "synchronized はシンプルで自動アンロックですが、ReentrantLock は手動ロック・アンロック代わりに、タイムアウト・フェアロック等の制御が可能です。"
        },
        {
            "id": "java_concurrency_058",
            "question": "volatile キーワード単独での同期効果として最も適切なものはどれか。",
            "choices": [
                "完全な同期を提供する",
                "変数の可視性を保証するが、原子性は保証しない。multiple increment ++ 等は依然として競合状態（Race Condition）発生",
                "volatile は同期とは無関係",
                "volatile があれば synchronization は不要"
            ],
            "answer": 1,
            "explanation": "volatile は『全スレッドに即座に見える』ことを保証しますが、volatile counter++; の ++　操作は『読」+『変更』+『書き込み』3ステップであり、複数スレッド間で競合が発生すう。"
        },
        {
            "id": "java_concurrency_059",
            "question": "Thread.join() の役割として最も適切なものはどれか。",
            "choices": [
                "スレッドを強制終了する",
                "呼出し元スレッドが、指定スレッドの完了まで待機する仕組み",
                "Thread.join() は使用すべきでない",
                "スレッド間通信に使用"
            ],
            "answer": 1,
            "explanation": "main スレッドが worker.join() すると、worker スレッド完了まで main は中断されます。複数スレッドの並行実行後、全て完了を待つ典型的パターンです。"
        },
        {
            "id": "java_concurrency_060",
            "question": "Callable と Runnable の相違点として最も適切なものはどれか。",
            "choices": [
                "機能は同じ",
                "Runnable は戻り値なし、Callable は戻り値返却可能。ExecutorService.submit(Callable) は Future で結果を取得可能",
                "Callable は実装が面倒",
                "Runnable の方が新しい"
            ],
            "answer": 1,
            "explanation": "Future<Integer> result = executor.submit(() -> compute()); のように、Callable により計算結果を非同期に取得できます。result.get() でブロック待機も可能です。"
        }
    ],
    "java_annotations": [
        {
            "id": "java_annotations_051",
            "question": "アノテーション処理における『リテンション ポリシー（RetentionPolicy）』の役割として最も適切なものはどれか。",
            "choices": [
                "アノテーションの記述方法を定義する",
                "@Retention にて、アノテーション情報を SOURCE（コンパイル後破棄）・CLASS（クラスファイルに保持）・RUNTIME（実行時に利用可能）のいずれまで保持するか指定",
                "リテンションポリシーはアノテーションと無関係",
                "常に RUNTIME で固定"
            ],
            "answer": 1,
            "explanation": "@Retention(RetentionPolicy.RUNTIME) で実行時リフレクション対応、RUNTIME なしでは実行時の自動処理（フレームワーク）に利用不可です。"
        },
        {
            "id": "java_annotations_052",
            "question": "アノテーションプロセッサ（Annotation Processor）の用途として最も適切なものはどれか。",
            "choices": [
                "実行時のみ動作",
                "コンパイル時にアノテーションを読み込み、ソースコード・クラスファイル生成、検証を実用。Lombork、Butterknife が代表例",
                "アノテーションプロセッサは非効率",
                "リフレクション専用"
            ],
            "answer": 1,
            "explanation": "@Data アノテーション（Lombok）によりコンパイル時に getter・setter・equals() 等を自動生成し、ボイラープレートコード削減が実現します。"
        },
        {
            "id": "java_annotations_053",
            "question": "カスタムアノテーション定義で『@Target メタアノテーション』の役割として最も適切なものはどれか。",
            "choices": [
                "アノテーションの処理方法を指定",
                "@Target(ElementType.METHOD) のようにアノテーション適用対象（METHOD, TYPE, FIELD等）を限定し、不正使用を防止",
                "@Target なしでもアノテーションは機能",
                "ターゲットはすべての要素で同じ"
            ],
            "answer": 1,
            "explanation": "@Target(ElementType.METHOD) で METHOD のみに適用可能な限定的アノテーションが定義でき、@MyAnnotation を class に付与しようとするとコンパイルエラー。"
        },
        {
            "id": "java_annotations_054",
            "question": "リフレクション API を使用した動的アノテーション処理の活用シーンとして最も適切なものはどれか。",
            "choices": [
                "コンパイル時ののみ",
                "フレームワーク（Spring の @Autowired, JUnit の @Test）は実行時にリフレクションでアノテーション検索、対応処理を実行か動的実装が可能",
                "リフレクション処理はパフォーマンス低下のため避けるべき",
                "アノテーションはリフレクション不要で機能"
            ],
            "answer": 1,
            "explanation": "Spring のコンテナは @Autowired を実行時に検索し、リフレクションでフィールド取得、依存性注入を自動実行します。"
        },
        {
            "id": "java_annotations_055",
            "question": "アノテーションのメンバー変数（要素）での『デフォルト値』設定の重要性として最も適切なものはどれか。",
            "choices": [
                "デフォルト値の指定は任意",
                "デフォルト値を定義することで、アノテーション使用時に全要素の指定が必須でなく、必要な要素のみ指定可能で利便性向上",
                "デフォルト値なしでもアノテーション使用は可能",
                "すべての要素は常にデフォルト値必須"
            ],
            "answer": 1,
            "explanation": "@RequestMapping(value=\"/api\") で value のみ指定可能なのは、method 等他の要素がデフォルト値を持つためです。"
        },
        {
            "id": "java_annotations_056",
            "question": "アノテーション継承の扱いについて最も適切な説明はどれか。",
            "choices": [
                "アノテーション継承は自動的に発生",
                "@Inherited メタアノテーション なしでは、サブクラスはスーパークラスのアノテーション継承しない。必要な場合は明示的に @Inherited 指定",
                "すべてのアノテーションは継承される",
                "継承はアノテーションに関係ない"
            ],
            "answer": 1,
            "explanation": "@Inherited なしでは class Child extends Parent { } のもとで、Parent の @MyAnnotation は Child に継承されません。継承を意図する場合は @Inherited を定義時に指定。"
        },
        {
            "id": "java_annotations_057",
            "question": "リフレクション時の『getMethod()・getDeclaredMethod()』の相違点として最も適切なものはどれか。",
            "choices": [
                "機能は同じ",
                "getMethod() は public のみ、getDeclaredMethod() は private・protected を含む全メソッドを取得。スーパークラスの private は対象外",
                "getDeclaredMethod() は遅い",
                "getMethod() の方が推奨"
            ],
            "answer": 1,
            "explanation": "clazz.getMethod(\"method\") は public のみ、clazz.getDeclaredMethod(\"method\") は private を含む宣言メソッドを取得し、setAccessible(true) で private アクセス可能。"
        },
        {
            "id": "java_annotations_058",
            "question": "型安全なアノテーション処理を実装するための推奨方法として最も適切なものはどれか。",
            "choices": [
                "Class.forName() でクラスロード文字列マジック数を使用",
                "ジェネリック Method.getAnnotation(Class<T>) で型安全取得。getAnnotation(MyAnnotation.class) で即座に MyAnnotation 型で返却",
                "文字列比較でアノテーション判定",
                "アノテーション処理は型安全化不可能"
            ],
            "answer": 1,
            "explanation": "Method.getAnnotation(RequestMapping.class) により RequestMapping 型で返却され、.value() で値取得。型キャストなし、安全・直感的です。"
        },
        {
            "id": "java_annotations_059",
            "question": "バリデーションアノテーション（@Valid, @NotNull 等）の実装フレームワークとして最も適切なものはどれか。",
            "choices": [
                "標準 Java に組込み.",
                "Jakarta Validation（旧 JSR-303）フレームワーク。Hibernate Validator が代表実装で、自動バリデーション・カスタムルール拡張可能",
                "バリデーションは手書きすべき",
                "アノテーションバリデーションは非効率"
            ],
            "answer": 1,
            "explanation": "@Entity class Person { @NotNull String name; } の自動バリデーションは Hibernate Validator により、データベース永続化時に自動実行されます。"
        },
        {
            "id": "java_annotations_060",
            "question": "Spring フレームワークで @ComponentScan を使用する目的として最も適切なものはどれか。",
            "choices": [
                "コンポーネントの手動登録のみ",
                "指定パッケージ配下の @Component・@Service・@Repository 等アノテーション付き클래스를 自動スキャン・Bean 登録し、DI コンテナ初期化を自動化",
                "@ComponentScan なしでも自動検出",
                "パッケージスキャンはパフォーマンス低下"
            ],
            "answer": 1,
            "explanation": "@ComponentScan(\"com.example\") により、com.example 配下の @Service class UserService のの自動検出・Bean 登録が有効になります。"
        }
    ],
    "sql_window_functions": [
        {
            "id": "sql_window_functions_051",
            "question": "ウィンドウ関数の『パーティション（PARTITION BY）』句が重要な理由として最も適切なものはどれか。",
            "choices": [
                "パーティション句なしでもウィンドウ関数は機能",
                "PARTITION BY により行を論理グループに分割し、各グループ内での計算（ランク、集約等）を個別実行。全体計算から選別計算への切替を実現",
                "パーティションは SQL で使用できない",
                "パフォーマンス低下のみ"
            ],
            "answer": 1,
            "explanation": "SELECT department, salary, ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) FROM employees により、部門毎の給与ランクが計算できます。"
        },
        {
            "id": "sql_window_functions_052",
            "question": "ROWS/RANGE 句を使用したフレーム定義の用途として最も適切なものはどれか。",
            "choices": [
                "全テーブル行に対して一律計算",
                "ROWS BETWEEN 1 PRECEDING AND CURRENT ROW により、現在行と前1行の間での移動平均・累計を計算。動的フレーム",
                "ROWS/RANGE は deprecated",
                "フレーム設定は任意で効果差なし"
            ],
            "answer": 1,
            "explanation": "SUM(amount) OVER (ORDER BY date ROWS BETWEEN 1 PRECEDING AND CURRENT ROW) で日毎の2日移動合計が計算でき、トレンド分析に活用。"
        },
        {
            "id": "sql_window_functions_053",
            "question": "LAG/LEAD 関数の用途として最も適切なものはどれか。",
            "choices": [
                "集約計算のみ",
                "LAG で前行、LEAD で次行の値を論理的に参照。前年売上との比較、期間差分計算等が単純に実現",
                "LAGと LEAD は同一機能",
                "Self-Join のみで対応すべき"
            ],
            "answer": 1,
            "explanation": "LAG(salary, 1) OVER (ORDER BY year) で前年給与を取得、今年給与との差分計算で年間昇給額が抽出できます。Self-Join より簡潔。"
        },
        {
            "id": "sql_window_functions_054",
            "question": "NTILE 関数をデータ分析で活用する場面として最も適切なものはどれか。",
            "choices": [
                "パフォーマンス分析のみ",
                "NTILE(4) で行を四分位数に分類。売上客を TOP・HIGH・MEDIUM・LOW 四分類し、マーケティング施策区別化等で活用",
                "NTILE は実用性なし",
                "NTILE は統計計算不要"
            ],
            "answer": 1,
            "explanation": "SELECT customer, sales, NTILE(4) OVER (ORDER BY sales DESC) as segment FROM sales で顧客を4グループに分け、グループ別アプローチが可能。"
        },
        {
            "id": "sql_window_functions_055",
            "question": "PERCENT_RANK・CUME_DIST 関数の相違点として最も適切なものはどれか。",
            "choices": [
                "機能は同じ",
                "PERCENT_RANK は相対ランク（0～1）返却、CUME_DIST は累積分布（同値含む）返却。分位数計算で用途異なる",
                "CUME_DIST は未推奨",
                "両者は統計意味が同じ"
            ],
            "answer": 1,
            "explanation": "PERCENT_RANK() で相対位置（例：0.5 = 中央値）、CUME_DIST() で累積確率（例：0.75 = 75%未満）が得られ、分析視点が異なる。"
        },
        {
            "id": "sql_window_functions_056",
            "question": "複数の ORDER BY 列でのウィンドウ関数計算における注意点として最も適切なものはどれか。",
            "choices": [
                "複数 ORDER BY は未対応",
                "ORDER BY year, month のように複数列指定時、タイ（同値）の扱いが重要。ROW_NUMBER は strict order、RANK/DENSE_RANK はタイの束処理。仕様熟知が必須",
                "複数 ORDER BY はパフォーマンス低下",
                "単一列 ORDER BY のみ推奨"
            ],
            "answer": 1,
            "explanation": "ROW_NUMBER() OVER (ORDER BY score, name) でタイスコア時に名前順の厳密な行番号付与、RANK() は同一スコアに同一ランク付与で意味が異なります。"
        },
        {
            "id": "sql_window_functions_057",
            "question": "ウィンドウ関数を用いた『データギャップ検出』の実装方法として最も適切なものはどれか。",
            "choices": [
                "GROUP BY で全件チェック",
                "LAG で前行値を取得、current - previous を計算。予期しない gap>1 で欠落データを検出。続番号テーブル不要",
                "ギャップ検出は SQL で困難",
                "外部ツールで補完すべき"
            ],
            "answer": 1,
            "explanation": "SELECT date, date - LAG(date) OVER (ORDER BY date) as gap FROM events で日付欠落を検出、gap > 1 で異常を即座に見つけられます。"
        },
        {
            "id": "sql_window_functions_058",
            "question": "FIRST_VALUE/LAST_VALUE を用いた分析シーンとして最も適切なものはどれか。",
            "choices": [
                "単純な集約のみ",
                "FIRST_VALUE で期間開始値、LAST_VALUE で終了値を取得。期間変動率（終値-開始値）/開始値、多期間分析を効率実現",
                "FIRST_VALUE/LAST_VALUE は汎用性低い",
                "MAX/MIN のみで代替可能"
            ],
            "answer": 1,
            "explanation": "SELECT month, price, FIRST_VALUE(price) OVER (ORDER BY month), LAST_VALUE(price) OVER (ORDER BY month) で月別変動率算出が単純化。"
        },
        {
            "id": "sql_window_functions_059",
            "question": "ウィンドウ関数を使用した『ランク付与アルゴリズム』の選定基準として最も適切なものはどれか。",
            "choices": [
                "常に ROW_NUMBER を使用",
                "目的により異なる：タイ（同値）を異なる番号で扱う→ROW_NUMBER、同一番号→RANK（スキップあり）/DENSE_RANK（スキップなし）",
                "RANK と DENSE_RANK の選別は不要",
                "ランク付与は集約関数で代替"
            ],
            "answer": 1,
            "explanation": "スコア 100, 100, 90 に ROW_NUMBER 付与は (1,2,3)、RANK は (1,1,3)、DENSE_RANK は (1,1,2)。順位表示方式により選別。"
        },
        {
            "id": "sql_window_functions_060",
            "question": "ウィンドウ関数の性能最適化において重要な考慮点として最も適切なものはどれか。",
            "choices": [
                "インデックス有無とは無関係",
                "ORDER BY 列へのインデックス、JOIN キーのインデックス確保、不要なウィンドウサイズ削減（PARTITION 粒度最適化）により、実行計画効率化",
                "ウィンドウ関数はインデックス非効率",
                "性能調査は不要"
            ],
            "answer": 1,
            "explanation": "PARTITION BY department, ORDER BY salary の場合、(department, salary) 複合インデックスにより、ウィンドウ処理が大幅高速化。"
        }
    ],
    "sql_advanced": [
        {
            "id": "sql_advanced_051",
            "question": "クエリ最適化において『実行計画（Execution Plan）』を解析する目的として最も適切なものはどれか。",
            "choices": [
                "実行計画は参考情報のみ",
                "実行計画により、使用インデックス、結合順序、Full Table Scan の有無等を把握。ボトルネック同定・チューニング方針立案が可能",
                "実行計画は常に最適",
                "手動チューニングは実行計画と独立"
            ],
            "answer": 1,
            "explanation": "EXPLAIN ANALYZE SELECT ... で実行計画確認、Full Seq Scan が見られたら WHERE 条件のインデックス追加を検討。インデックス効かない述語は別途検討。"
        },
        {
            "id": "sql_advanced_052",
            "question": "複合インデックス（Composite/Compound Index）設計における最適な列順序として最も適切なものはどれか。",
            "choices": [
                "列順序はランダムで無影響",
                "『WHERE で絞込→範囲検索→ORDER BY・GROUP BY』の順に列配置（Leading Leading Problem）。最初の列で最大絞込率を実現",
                "複合インデックスは不要な複雑化",
                "単一列インデックスのみ推奨"
            ],
            "answer": 1,
            "explanation": "WHERE department = ? AND salary > ? ORDER BY age の場合、(department, salary, age) のような順序が最適。department で高速フィルタ、salary で範囲走査を効率化。"
        },
        {
            "id": "sql_advanced_053",
            "question": "選択的（Covering）インデックスの利点として最も適切なものはどれか。",
            "choices": [
                "一般的なインデックスと変わらない",
                "SELECT の全列をインデックスに含む場合、テーブルアクセス不要（インデックスのみ走査）。Index-Only Scan が成立し、I/O 大幅削減",
                "Covering インデックスは実装複雑",
                "テーブルアクセスは必須"
            ],
            "answer": 1,
            "explanation": "CREATE INDEX idx_covering ON users(department) INCLUDE (salary, name) で SELECT department, salary, name WHERE department = ? はインデックスのみで応答可能。テーブル RDB アクセス不要。"
        },
        {
            "id": "sql_advanced_054",
            "question": "統計情報（Statistics）が外れた場合のクエリ最適化への影響として最も適切なものはどれか。",
            "choices": [
                "統計情報と実行計画は無関係",
                "クエリオプティマイザが行数見誤り、非効率な実行計画（適切なインデックス未使用等）を選択。パフォーマンス劣化",
                "統計情報は一度作成すれば不変",
                "統計更新は不要"
            ],
            "answer": 1,
            "explanation": "ANALYZE TABLE users, UPDATE STATISTICS users で統計更新。統計古いと『実稲果として Full Scan より インデックス走査の方が高速』でも Optimizer が誤判定。"
        },
        {
            "id": "sql_advanced_055",
            "question": "結合（JOIN）性能のチューニングにおける結合順序最適化として最も適切なものはどれか。",
            "choices": [
                "結合順序はランダムで影響なし",
                "『小さいテーブル先』を原則。Nested Loop では内側テーブルが小さいほど I/O 削減。複数テーブル結合時の最適順序は統計・オプティマイザに依存するが、プランナ制御も可能",
                "大きいテーブル先が常に効率的",
                "結合順序制御は不可能"
            ],
            "answer": 1,
            "explanation": "SELECT ... FROM orders o JOIN customers c ... の場合、customers（小）が内側の方が効率的。複数テーブル結合時は SELECT /*+ LEADING(orders) */ で JOIN 順序強制可能（DB 依存）。"
        },
        {
            "id": "sql_advanced_056",
            "question": "N+1 問題による性能劣化を根本解決するアプローチとして最も適切なものはどれか。",
            "choices": [
                "N+1 は回避不可能",
                "『まず親取得 → 親IDで子一括取得（IN句）』の2ステップ、または JOIN で単一クエリ化。ORM の eager loading 活用で削減",
                "キャッシュのみで対応可能",
                "子テーブルは全て非正規化すべき"
            ],
            "answer": 1,
            "explanation": "SELECT * FROM orders; (親1件) + SELECT * FROM order_items WHERE order_id = ? (子N件) ではN+1クエリ。SELECT * FROM orders o LEFT JOIN order_items oi で単一クエリ化。"
        },
        {
            "id": "sql_advanced_057",
            "question": "部分インデックス（Partial/Filtered Index）の活用シーンとして最も適切なものはどれか。",
            "choices": [
                "標準インデックス同様すべての行対象",
                "WHERE active = true のようなフィルタ条件で、インデックスサイズ削減・キャッシュ効率向上。削除済みレコード等の無駄行対象外化",
                "部分インデックスは全 DB で非対応",
                "フィルタ条件は SQL で充分"
            ],
            "answer": 1,
            "explanation": "CREATE INDEX idx_active_users ON users(name) WHERE active = true で削除ユーザー除外。インデックスサイズ削減、大規模テーブルで顕著な効果。"
        },
        {
            "id": "sql_advanced_058",
            "question": "スキャン方式の『Table Scan vs Index Scan』選別に影響する要因として最も適切なものはどれか。",
            "choices": [
                "インデックス常に最適",
                "検索条件の選別率・取得列数・テーブル並べ替え順序で判定。広範囲行検索時は Full Table Scan、狭い範囲は Index Scan が効率的",
                "Table Scan は非推奨",
                "オプティマイザは常に最適判定"
            ],
            "answer": 1,
            "explanation": "WHERE salary > 50000 で全社員50%取得なら Table Scan が効率的（ランダム I/O 削減）。WHERE department = ? で1% なら Index Scan が効率的。"
        },
        {
            "id": "sql_advanced_059",
            "question": "デッドロック（Database-level）を回避するための設計原則として最も適切なものはどれか。",
            "choices": [
                "デッドロック回避は不可能",
                "『一貫した行アクセス順序』『トランザクション期間最小化』『アイソレーションレベル選別（Read Committed が無難）』で削減。発生時の再試行機構も必須",
                "デッドロック発生は常态",
                "全トランザクション serializable 必須"
            ],
            "answer": 1,
            "explanation": "トランザクション A（orders → items → payments アクセス）と B（payments → items → orders）はデッドロック可能性。常に共通順序でアクセスすることで回避。"
        },
        {
            "id": "sql_advanced_060",
            "question": "並行制御（Concurrency Control）における『ロック戦略』として最も適切なものはどれか。",
            "choices": [
                "全トランザクション排他ロック",
                "読み取り共有ロック・更新排他ロック等を分別。不要なロック時間削減・パラレル度向上。Snapshot Isolation 等の非ロック方式の活用",
                "ロック無し（Lock-Free）が常に最適",
                "ロック機構は DB 内部で隠蔽、ユーザー制御不可"
            ],
            "answer": 1,
            "explanation": "読み取りと読み取りは共存（共有ロック）、更新は排他。PostgreSQL の MVCC（Snapshot Isolation）で短トランザクションのロック回避が可能。"
        }
    ]
}

# Add more category data mappings as needed...

def load_json_file(filepath):
    """Load existing JSON file"""
    with open(filepath, 'r', encoding='utf-8') as f:
        return json.load(f)

def save_json_file(filepath, data):
    """Save JSON file with proper formatting"""
    with open(filepath, 'w', encoding='utf-8') as f:
        json.dump(data, f, ensure_ascii=False, indent=2)
    print(f"Updated: {filepath}")

def augment_question_file(file_path, category_key, supplementary_questions):
    """Add 50 new questions to an existing question file"""
    try:
        data = load_json_file(file_path)

        existing_count = len(data.get("questions", []))
        if existing_count != 50:
            print(f"  Warning: {category_key} has {existing_count} questions, expected 50")

        # Add supplementary questions
        data["questions"].extend(supplementary_questions)

        # Save updated file
        save_json_file(file_path, data)
        print(f"  ✓ Added {len(supplementary_questions)} questions to {category_key}")
        return True
    except Exception as e:
        print(f"  ✗ Error processing {file_path}: {str(e)}")
        return False

def main():
    """Main function to process all files"""
    base_path = Path("c:/git/waos/exam-questions/data")

    # Define file paths and their corresponding supplementary questions
    files_to_update = {
        "lang/questions_sa_security.json": ("sa_security", SUPPLEMENTARY_QUESTIONS.get("sa_security", [])),
        "lang/questions_java_generics_lambda.json": ("java_generics_lambda", SUPPLEMENTARY_QUESTIONS.get("java_generics_lambda", [])),
        "lang/questions_java_concurrency.json": ("java_concurrency", SUPPLEMENTARY_QUESTIONS.get("java_concurrency", [])),
        "lang/questions_java_annotations.json": ("java_annotations", SUPPLEMENTARY_QUESTIONS.get("java_annotations", [])),
        "lang/questions_sql_window_functions.json": ("sql_window_functions", SUPPLEMENTARY_QUESTIONS.get("sql_window_functions", [])),
        "lang/questions_sql_advanced.json": ("sql_advanced", SUPPLEMENTARY_QUESTIONS.get("sql_advanced", [])),
    }

    print("=" * 80)
    print("STARTING SUPPLEMENTARY QUESTION AUGMENTATION")
    print("=" * 80)

    updated_count = 0
    for relative_path, (category_key, supplementary_questions) in files_to_update.items():
        file_path = base_path / relative_path
        print(f"\nProcessing: {relative_path}")

        if not supplementary_questions:
            print(f"  ⚠ No supplementary questions defined for {category_key}")
            continue

        if file_path.exists():
            if augment_question_file(str(file_path), category_key, supplementary_questions):
                updated_count += 1
        else:
            print(f"  ✗ File not found: {file_path}")

    print("\n" + "=" * 80)
    print(f"COMPLETION: Updated {updated_count} files")
    print("=" * 80)

if __name__ == "__main__":
    main()
