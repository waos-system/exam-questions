{
  "genre": "システム",
  "exam": "応用情報技術者試験",
  "category": "ap_system",
  "questions": [
    {
      "id": "ap_sys_001",
      "question": "マイクロサービスアーキテクチャの特徴として適切でないものはどれか？",
      "choices": [
        "サービス間の独立したデプロイが可能",
        "サービス単位でスケールアウトができる",
        "全サービスが単一のデータベースを共有する",
        "サービス間はAPIで通信する"
      ],
      "answer": 2,
      "explanation": "マイクロサービスではサービスごとに適切なDBを持つ（Database per Service）のが原則。単一DBの共有はモノリシックアーキテクチャの特徴でマイクロサービスでは疎結合を維持するため避ける。"
    },
    {
      "id": "ap_sys_002",
      "question": "イベント駆動アーキテクチャ（EDA）のメリットとして適切なものはどれか？",
      "choices": [
        "サービス間の同期通信で信頼性が高い",
        "サービスの疎結合化とスケーラビリティ向上",
        "全イベントが即座に処理される保証",
        "システム全体のデータ整合性が常に保たれる"
      ],
      "answer": 1,
      "explanation": "EDAはイベントブローカー（Kafka等）を介して非同期にイベントを配信し、生産者と消費者を疎結合にすることでスケーラビリティと柔軟性を向上させる。ただしEventual Consistencyになる。"
    },
    {
      "id": "ap_sys_003",
      "question": "CQRS（Command Query Responsibility Segregation）の説明として適切なものはどれか？",
      "choices": [
        "データベースの読み書きを分離して最適化する設計パターン",
        "SQLのCRUD操作を分離するパターン",
        "マイクロサービスの通信パターン",
        "APIゲートウェイの設計パターン"
      ],
      "answer": 0,
      "explanation": "CQRSは書き込み（Command）と読み取り（Query）のモデルを分離する設計パターン。書き込みは正規化DBで整合性を保ち、読み取りは非正規化ビューで高速化できる。EventSourcingと組み合わせることが多い。"
    },
    {
      "id": "ap_sys_004",
      "question": "サービスメッシュ（Istio等）の主な機能として適切でないものはどれか？",
      "choices": [
        "サービス間通信のmTLS暗号化",
        "トラフィック管理（カナリアリリース・サーキットブレーカー）",
        "サービスの自動スケーリング",
        "オブザーバビリティ（分散トレーシング・メトリクス）"
      ],
      "answer": 2,
      "explanation": "サービスメッシュはサイドカープロキシを通じてサービス間通信の制御・セキュリティ・オブザーバビリティを提供するが、自動スケーリングはKubernetesのHPA/VPAの機能でサービスメッシュの機能ではない。"
    },
    {
      "id": "ap_sys_005",
      "question": "レイテンシとスループットのトレードオフの説明として適切なものはどれか？",
      "choices": [
        "バッチ処理はレイテンシを下げてスループットを上げる",
        "バッファリングでスループットは上がるがレイテンシが増加する",
        "キャッシュはスループットを下げてレイテンシを下げる",
        "並列処理はスループットを下げてレイテンシを下げる"
      ],
      "answer": 1,
      "explanation": "バッファリング（まとめて処理）はスループット（単位時間当たりの処理量）を上げるが、バッファが溜まるまで待つため個々のレイテンシは増加する。両者はトレードオフの関係。"
    },
    {
      "id": "ap_sys_006",
      "question": "Twelve-Factor Appの原則に含まれるものとして適切なものはどれか？",
      "choices": [
        "コードベースを複数のリポジトリで管理する",
        "設定を環境変数に格納する",
        "ステートフルなプロセスとして実行する",
        "全サービスを1つのプロセスで動かす"
      ],
      "answer": 1,
      "explanation": "Twelve-Factor Appの5番目の要素「設定」では、環境（開発・ステージング・本番）間で変わる設定は環境変数に格納するべきとしている。コードへのハードコードやファイルへの格納は避ける。"
    },
    {
      "id": "ap_sys_007",
      "question": "APIゲートウェイのハイドラプターン（Backend For Frontend）の説明として適切なものはどれか？",
      "choices": [
        "全クライアントが同じAPIを使用する",
        "クライアント（モバイル・Web・IoT）ごとに最適化されたAPIを提供する",
        "APIの認証のみを担当する",
        "マイクロサービスを1つのサービスにまとめる"
      ],
      "answer": 1,
      "explanation": "BFF（Backend For Frontend）はクライアントの種別（モバイル・ブラウザ・IoT）ごとに専用のAPIゲートウェイを配置し、それぞれのクライアントに最適なデータ形式・機能を提供するパターン。"
    },
    {
      "id": "ap_sys_008",
      "question": "サーキットブレーカーパターンの説明として適切なものはどれか？",
      "choices": [
        "電力の過負荷から機器を保護する物理的なブレーカー",
        "下流サービスの障害時に呼び出しを遮断してカスケード障害を防ぐ設計パターン",
        "ネットワーク障害を自動的に修復するパターン",
        "データベース接続を管理するパターン"
      ],
      "answer": 1,
      "explanation": "サーキットブレーカーは下流サービスへの呼び出しが連続失敗するとOpen状態になり呼び出しを遮断、一定時間後にHalf-Open状態でテスト呼び出しを行い、成功すればClosed状態に戻す。Netflixのレジリエンスパターン。"
    },
    {
      "id": "ap_sys_009",
      "question": "稼働率99.99%（「フォーナイン」）のシステムで年間に許容されるダウンタイムとして最も近いものはどれか？",
      "choices": [
        "約8.7時間",
        "約52分",
        "約1時間",
        "約5.3分"
      ],
      "answer": 1,
      "explanation": "99.99%の稼働率は0.01%のダウンタイムを許容する。年間8760時間 × 0.0001 = 0.876時間 = 約52.6分がダウンタイム上限となる。"
    },
    {
      "id": "ap_sys_010",
      "question": "カオスエンジニアリングの説明として適切なものはどれか？",
      "choices": [
        "システムを無計画に変更してバグを発見する手法",
        "本番環境に意図的に障害を注入してシステムの耐障害性を検証する手法",
        "コードの品質を改善するリファクタリング手法",
        "サービスのパフォーマンスを測定する手法"
      ],
      "answer": 1,
      "explanation": "カオスエンジニアリングはNetflixのChaos Monkeyに始まり、本番環境でサーバ停止・ネットワーク遅延・CPU負荷などの障害を意図的に注入してシステムの回復力（レジリエンス）を検証・改善する手法。"
    },
    {
      "id": "ap_sys_011",
      "question": "サービスレベル目標（SLO）と誤差バジェットの関係として適切なものはどれか？",
      "choices": [
        "SLOを高く設定するほど誤差バジェットが大きくなる",
        "SLOを100%に設定すると誤差バジェットがゼロになり変更リリースが困難になる",
        "誤差バジェットはSLO達成率と無関係",
        "誤差バジェットはデバッグに使用する時間"
      ],
      "answer": 1,
      "explanation": "誤差バジェット = 1 - SLO。SLOが99.9%なら誤差バジェットは0.1%。これをリリースや実験に使う。100%SLOは誤差バジェット0でリスクのある変更が全くできなくなる。SREの基本概念。"
    },
    {
      "id": "ap_sys_012",
      "question": "スケールアップとスケールアウトの説明として適切なものはどれか？",
      "choices": [
        "スケールアップはサーバ数を増やし、スケールアウトはサーバのスペックを上げる",
        "スケールアップはサーバのスペックを上げ（垂直スケーリング）、スケールアウトはサーバ数を増やす（水平スケーリング）",
        "両者は同義",
        "スケールアップはクラウドのみで可能"
      ],
      "answer": 1,
      "explanation": "スケールアップ（垂直スケーリング）はCPU・メモリなどリソースを増強する。スケールアウト（水平スケーリング）はサーバ台数を増やして負荷分散する。クラウドではスケールアウトが主流。"
    },
    {
      "id": "ap_sys_013",
      "question": "サーバレスアーキテクチャ（FaaS）のデメリットとして適切なものはどれか？",
      "choices": [
        "インフラ管理が不要",
        "自動スケーリング",
        "コールドスタートによるレイテンシ増加",
        "使用量ベースの課金"
      ],
      "answer": 2,
      "explanation": "FaaS（AWS Lambda等）のデメリットはコールドスタート（関数が長時間未実行後の初回起動遅延）、実行時間制限、ベンダーロックイン、ステートレス制約など。"
    },
    {
      "id": "ap_sys_014",
      "question": "マルチリージョンアーキテクチャで「アクティブ-アクティブ」構成の特徴として適切なものはどれか？",
      "choices": [
        "障害時のみバックアップリージョンが起動する",
        "複数リージョンが同時に本番トラフィックを処理しより低レイテンシとゼロダウンタイムを実現する",
        "データはプライマリリージョンのみに存在する",
        "RPOが高くなる"
      ],
      "answer": 1,
      "explanation": "アクティブ-アクティブは全リージョンが常時トラフィックを処理する構成で、単一障害点なし・低レイテンシ・高可用性を実現。データ同期の複雑さとコストが課題。アクティブ-スタンバイより高価。"
    },
    {
      "id": "ap_sys_015",
      "question": "データグリッドパターン（In-Memory Data Grid）の用途として適切なものはどれか？",
      "choices": [
        "ディスクベースのデータ永続化",
        "複数ノードにまたがるインメモリキャッシュと分散データ処理の高速化",
        "グラフデータの管理",
        "ファイルストレージの管理"
      ],
      "answer": 1,
      "explanation": "IMDGはHazelcast・Apache Igniteなどで実装される分散インメモリキャッシュ。複数サーバのメモリをプールしてデータを分散格納し、DBアクセスを削減して超低遅延を実現する。セッション管理・リアルタイム分析に使用。"
    },
    {
      "id": "ap_sys_016",
      "question": "オートスケーリングの「水平スケーリングのクールダウン期間」の説明として適切なものはどれか？",
      "choices": [
        "スケールイン・スケールアウト後に一定時間新たなスケーリングを抑制して安定性を保つ期間",
        "スケールアウト完了後にインスタンスが冷却する物理的な時間",
        "スケールアウトの最小間隔を決めるSLA条件",
        "インスタンスが起動してから機能するまでの初期化時間"
      ],
      "answer": 0,
      "explanation": "クールダウン期間はスケーリングアクション実行後に次のスケーリングを一定時間（例：300秒）抑制することで、過剰なスケーリングによる振動（スラッシング）を防ぐ機能。"
    },
    {
      "id": "ap_sys_017",
      "question": "分散システムの「結果整合性（Eventual Consistency）」の説明として適切なものはどれか？",
      "choices": [
        "全ノードが常に最新データを持つことを保証する",
        "更新は最終的に全ノードに伝播するが一時的に不整合が存在する",
        "全操作を直列化して整合性を保証する",
        "トランザクションのACIDを保証する"
      ],
      "answer": 1,
      "explanation": "結果整合性はDNS・DynamoDB・Cassandraなどで採用。更新は非同期に伝播するため一時的に古い値を読む可能性があるが、最終的に全ノードが整合する。可用性とパーティション耐性を優先するCAP定理のAPシステム。"
    },
    {
      "id": "ap_sys_018",
      "question": "Kubernetes（K8s）のDeploymentリソースのローリングアップデート戦略の説明として適切なものはどれか？",
      "choices": [
        "全てのPodを一度に削除してから新バージョンのPodを起動する",
        "古いPodを段階的に新バージョンのPodに置き換えてダウンタイムをゼロにする",
        "新旧バージョンを並行稼働させてトラフィックを分割する",
        "新バージョンのPodが全て起動してから古いPodを削除する"
      ],
      "answer": 1,
      "explanation": "ローリングアップデートはmaxUnavailableとmaxSurgeパラメータで古いPodを段階的に新Podに置き換え、サービスを維持しながらダウンタイムゼロでデプロイする。"
    },
    {
      "id": "ap_sys_019",
      "question": "Saga パターンの説明として適切なものはどれか？",
      "choices": [
        "マイクロサービス間の2フェーズコミットで強整合性を確保するパターン",
        "マイクロサービス間にまたがる長期トランザクションを補償トランザクションで管理するパターン",
        "イベントソーシングのストレージパターン",
        "APIゲートウェイの認証パターン"
      ],
      "answer": 1,
      "explanation": "Sagaパターンはマイクロサービス間の分散トランザクションを一連のローカルトランザクションとして実装し、失敗時は補償トランザクション（ロールバック相当）で整合性を回復する。コレオグラフィ型とオーケストレーション型がある。"
    },
    {
      "id": "ap_sys_020",
      "question": "リアクティブシステムの4つの特性（Reactive Manifesto）として適切なものはどれか？",
      "choices": [
        "速さ・信頼性・拡張性・効率性",
        "即応性・耐障害性・弾力性・メッセージ駆動",
        "可用性・整合性・分断耐性・性能",
        "モジュール性・再利用性・保守性・テスト容易性"
      ],
      "answer": 1,
      "explanation": "Reactive ManifestoはResponsive（即応性）・Resilient（耐障害性）・Elastic（弾力性）・Message Driven（メッセージ駆動）の4特性を持つシステムをリアクティブシステムと定義する。"
    },
    {
      "id": "ap_sys_021",
      "question": "ヘキサゴナルアーキテクチャ（ポートアンドアダプタ）の説明として適切なものはどれか？",
      "choices": [
        "UIとDBが直接連携するアーキテクチャ",
        "ビジネスロジックを中心に置き外部依存をポート/アダプタで分離してテスト容易性を高める",
        "マイクロサービスを六角形に配置するアーキテクチャ",
        "MVC（Model-View-Controller）の別名"
      ],
      "answer": 1,
      "explanation": "ヘキサゴナルアーキテクチャはDomain（コア）がPortsを通じて外部（DB・UI・外部API）と通信し、Adaptersが外部とPortsを繋ぐ。コアビジネスロジックを外部依存から独立させてテスタビリティを高める。"
    },
    {
      "id": "ap_sys_022",
      "question": "Feature Flagsの説明として適切なものはどれか？",
      "choices": [
        "バグ修正のためのコードフラグ",
        "コードをデプロイせずに機能のオン/オフを動的に切り替える仕組み",
        "セキュリティ機能の有効化フラグ",
        "データベースのインデックスフラグ"
      ],
      "answer": 1,
      "explanation": "Feature Flags（Feature Toggles）は機能をコードにデプロイ済みだが外部設定でON/OFFを制御する手法。カナリアリリース・A/Bテスト・段階的ロールアウトに使用し、問題時は即座にロールバック可能。"
    },
    {
      "id": "ap_sys_023",
      "question": "グリーン/ブルーデプロイメントの説明として適切なものはどれか？",
      "choices": [
        "環境ごとに色を付けて管理する手法",
        "本番（ブルー）と同じ環境（グリーン）を用意して切り替えることでダウンタイムなしのデプロイを実現する",
        "コードの色分けによる品質管理手法",
        "負荷分散のためのトラフィック分割手法"
      ],
      "answer": 1,
      "explanation": "ブルーグリーンデプロイは現行（ブルー）と同一の新環境（グリーン）を構築し、テスト後にルータでトラフィックを瞬時に切り替えてダウンタイムゼロのデプロイとロールバックを実現する。"
    },
    {
      "id": "ap_sys_024",
      "question": "オブザーバビリティ（可観測性）の三本柱として適切なものはどれか？",
      "choices": [
        "CPU使用率・メモリ使用率・ディスクIO",
        "ログ・メトリクス・分散トレーシング",
        "可用性・信頼性・保守性",
        "アラート・ダッシュボード・レポート"
      ],
      "answer": 1,
      "explanation": "オブザーバビリティの三本柱はLogs（ログ）・Metrics（メトリクス）・Traces（分散トレーシング）。複雑なマイクロサービス環境でシステムの内部状態を理解・デバッグするための基盤。"
    },
    {
      "id": "ap_sys_025",
      "question": "エッジコンピューティングの主な利点として適切なものはどれか？",
      "choices": [
        "中央データセンターへの集約によるコスト削減",
        "データ処理をデータ生成源の近くで行いレイテンシを削減する",
        "クラウドのコンピューティング能力を最大化する",
        "セキュリティの中央管理を実現する"
      ],
      "answer": 1,
      "explanation": "エッジコンピューティングはIoTデバイスや現場の近くでデータを処理することで、クラウドへの通信遅延を排除しリアルタイム性を実現。自動運転・工場のリアルタイム制御・AR/VRに重要。"
    },
    {
      "id": "ap_sys_026",
      "question": "RTO（Recovery Time Objective）とRPO（Recovery Point Objective）の説明として適切なものはどれか？",
      "choices": [
        "RTOはデータ損失の許容量、RPOは復旧にかかる許容時間",
        "RTOは許容される復旧時間目標、RPOは許容されるデータ損失時点の目標",
        "RTOとRPOは同義",
        "RTOは障害発生頻度、RPOは復旧コスト"
      ],
      "answer": 1,
      "explanation": "RTO（復旧時間目標）は障害発生から復旧完了までの許容時間。RPO（復旧ポイント目標）は障害発生時に許容できるデータ損失の時点（直前のバックアップまでの時間）。BCP/DRの基本指標。"
    },
    {
      "id": "ap_sys_027",
      "question": "クラウドネイティブアプリケーションの特性として適切でないものはどれか？",
      "choices": [
        "コンテナ化",
        "マイクロサービス",
        "イミュータブルインフラストラクチャ",
        "シングルホスト上での動作前提"
      ],
      "answer": 3,
      "explanation": "クラウドネイティブはコンテナ・マイクロサービス・DevOps・CI/CD・イミュータブルインフラで複数ホスト・クラウド環境での動作を前提とする。単一ホスト前提はオンプレ従来型の考え方。"
    },
    {
      "id": "ap_sys_028",
      "question": "キャッシュ戦略「ライトスルー（Write-Through）」の説明として適切なものはどれか？",
      "choices": [
        "データをキャッシュにのみ書き込み遅延してDBに反映する",
        "データをキャッシュとDBに同時に書き込む",
        "DBにのみ書き込みキャッシュを更新しない",
        "読み取り時にキャッシュにデータを格納する"
      ],
      "answer": 1,
      "explanation": "ライトスルーはキャッシュとDBへの書き込みを同期的に行うため一貫性は高いが書き込みレイテンシが増加する。Write-Backはキャッシュのみに書き書き込みが速いがDB反映前に障害でデータ損失のリスクがある。"
    },
    {
      "id": "ap_sys_029",
      "question": "Strangler Figパターンの説明として適切なものはどれか？",
      "choices": [
        "レガシーシステムを一度に全て置き換えるビッグバン移行",
        "レガシーシステムの機能を段階的に新システムに移行しレガシーを徐々に縮小する",
        "マイクロサービスの障害伝播を防ぐパターン",
        "APIバージョン管理のパターン"
      ],
      "answer": 1,
      "explanation": "Strangler Figパターンはイチジク（Strangler Fig）が木を徐々に枯らすように、レガシーシステムの機能を少しずつ新システムに移行し、リスクを最小化しながら段階的にシステムを刷新する手法。"
    },
    {
      "id": "ap_sys_030",
      "question": "サービスディスカバリの「クライアントサイドディスカバリ」の説明として適切なものはどれか？",
      "choices": [
        "サービスレジストリはサーバ側が管理する",
        "クライアントがサービスレジストリを参照してサービスのインスタンスを直接選択して通信する",
        "ロードバランサがサービス探索を行う",
        "DNSのみを使用してサービスを発見する"
      ],
      "answer": 1,
      "explanation": "クライアントサイドディスカバリはクライアントがEureka等のサービスレジストリを直接参照してインスタンスを取得しロードバランシングも自分で行う。Netflix Ribbonが採用。サーバサイドはALB等がレジストリを参照する。"
    }
  ]
}