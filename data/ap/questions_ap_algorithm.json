{
  "genre": "アルゴリズム",
  "exam": "応用情報技術者試験",
  "category": "ap_algorithm",
  "questions": [
    {
      "id": "ap_algo_001",
      "question": "ダイクストラ法で解けない問題として適切なものはどれか？",
      "choices": [
        "重み付き有向グラフの最短経路",
        "重み付き無向グラフの最短経路",
        "負の重みを持つ辺が存在するグラフの最短経路",
        "単一始点から全頂点への最短経路"
      ],
      "answer": 2,
      "explanation": "ダイクストラ法は非負の重みのグラフの最短経路を効率的に求めるアルゴリズム（O(E log V)）。負の重みがある場合はベルマン-フォード法を使用する。"
    },
    {
      "id": "ap_algo_002",
      "question": "クイックソートの平均計算量として適切なものはどれか？",
      "choices": [
        "O(n)",
        "O(n log n)",
        "O(n²)",
        "O(log n)"
      ],
      "answer": 1,
      "explanation": "クイックソートの平均計算量はO(n log n)。ピボット選択が悪い（すでに整列済みなど）場合の最悪ケースはO(n²)になる。ランダムピボット選択やメディアン-オブ-3で最悪ケースを回避できる。"
    },
    {
      "id": "ap_algo_003",
      "question": "動的計画法（DP）の特徴として適切なものはどれか？",
      "choices": [
        "全組み合わせを試す総当たり法",
        "再帰的に問題を分割して独立したサブ問題を解く",
        "重複するサブ問題の計算結果をメモ化して再利用する",
        "ヒューリスティックで近似解を求める"
      ],
      "answer": 2,
      "explanation": "DPは最適部分構造（全体の最適解がサブ問題の最適解から構成される）と重複部分問題（同じサブ問題が繰り返し現れる）の性質を利用し、計算結果をキャッシュして効率化する。"
    },
    {
      "id": "ap_algo_004",
      "question": "ハッシュテーブルの「オープンアドレス法」と「チェイン法」の説明として適切なものはどれか？",
      "choices": [
        "オープンアドレス法は別の配列を使い、チェイン法は新しいハッシュを計算する",
        "オープンアドレス法は衝突時に別のバケットを探索し、チェイン法は連結リストで衝突要素を管理する",
        "両者に性能差はない",
        "チェイン法はメモリ効率が高い"
      ],
      "answer": 1,
      "explanation": "衝突解決：オープンアドレス法は線形探索・2次探索・ダブルハッシングで別スロットを探索。チェイン法は各バケットに連結リストを設け衝突要素を追加。チェイン法は衝突時の性能劣化が少ない。"
    },
    {
      "id": "ap_algo_005",
      "question": "二分探索木（BST）が退化した場合の探索計算量として適切なものはどれか？",
      "choices": [
        "O(1)",
        "O(log n)",
        "O(n)",
        "O(n log n)"
      ],
      "answer": 2,
      "explanation": "BSTに昇順/降順でデータを挿入すると偏った木（線形リスト）になり、探索・挿入・削除がO(n)に退化する。AVL木・赤黒木などの平衡BSTはO(log n)を保証する。"
    },
    {
      "id": "ap_algo_006",
      "question": "最小全域木を求めるアルゴリズムとして適切なものはどれか？",
      "choices": [
        "ダイクストラ法",
        "プリム法・クラスカル法",
        "フロイド-ワーシャル法",
        "ベルマン-フォード法"
      ],
      "answer": 1,
      "explanation": "最小全域木（MST）：プリム法は現在のMSTに最小コストの辺を追加して成長させる。クラスカル法は辺をコスト昇順でソートしサイクルを作らない辺を追加する。どちらもグリーディアルゴリズム。"
    },
    {
      "id": "ap_algo_007",
      "question": "NP困難問題の特徴として適切なものはどれか？",
      "choices": [
        "多項式時間で解くアルゴリズムが存在する",
        "問題の難しさがNP問題以上であるが、NP問題ではない場合もある",
        "全ての問題が多項式時間で検証できる",
        "計算量がO(n log n)以下で解ける"
      ],
      "answer": 1,
      "explanation": "NP困難（NP-hard）はNPに属する全問題を多項式時間で変換できる問題クラス。NP-hardかつNPに属する問題がNP完全（NP-complete）。巡回セールスマン問題・整数計画問題などがNP-hardの例。"
    },
    {
      "id": "ap_algo_008",
      "question": "B木インデックスと比較したビットマップインデックスの特徴として適切なものはどれか？",
      "choices": [
        "高カーディナリティの列に適している",
        "低カーディナリティ（値の種類が少ない）列に対する集計クエリに適している",
        "行の挿入・更新・削除が高速",
        "OLTPに最適化されている"
      ],
      "answer": 1,
      "explanation": "ビットマップインデックスは列値ごとにビットマップを持ち、AND/OR演算で高速に集計できる。性別・状態コードなど低カーディナリティの列やDWH（OLAP）向き。頻繁な更新には不向き。"
    },
    {
      "id": "ap_algo_009",
      "question": "文字列探索のKMP（Knuth-Morris-Pratt）アルゴリズムの特徴として適切なものはどれか？",
      "choices": [
        "テキスト・パターン文字列を後ろから比較する",
        "パターン内の接頭辞・接尾辞情報を使い文字の比較を無駄なく行いO(n+m)を達成する",
        "ハッシュを使って文字列を比較する",
        "最悪ケースでO(n×m)になる"
      ],
      "answer": 1,
      "explanation": "KMPはパターンの部分一致情報（failure function）を事前計算し、不一致時に無駄なバックトラックをせず常にO(n+m)（n:テキスト長、m:パターン長）で探索できる。"
    },
    {
      "id": "ap_algo_010",
      "question": "グラフの幅優先探索（BFS）の用途として適切なものはどれか？",
      "choices": [
        "最短経路（重み付き）の探索",
        "重みなしグラフの最短経路（ホップ数）の探索",
        "トポロジカルソート",
        "連結成分数の計算（DFSより高速）"
      ],
      "answer": 1,
      "explanation": "BFSはキューを使いレベル順（近い頂点から）に探索するため、重みなしグラフで出発点から各頂点への最短ホップ数を正確に求められる。DFSはスタックを使う深さ優先探索。"
    },
    {
      "id": "ap_algo_011",
      "question": "ユニオンファインドデータ構造（素集合データ構造）の主な操作として適切なものはどれか？",
      "choices": [
        "要素の挿入と削除",
        "集合の「合併（Union）」と「代表元の検索（Find）」",
        "最小値・最大値の検索",
        "グラフの最短経路の計算"
      ],
      "answer": 1,
      "explanation": "ユニオンファインドは集合を管理するデータ構造で、Union（2つの集合を合併）とFind（要素が属する集合の代表元を返す）を経路圧縮とランク統合でほぼO(1)で実現。クラスカル法やネットワーク連結判定に使用。"
    },
    {
      "id": "ap_algo_012",
      "question": "ソートアルゴリズムで安定ソートに分類されるものとして適切なものはどれか？",
      "choices": [
        "クイックソート",
        "ヒープソート",
        "マージソート",
        "選択ソート"
      ],
      "answer": 2,
      "explanation": "安定ソートは等しいキーの要素の相対順序が保存されるアルゴリズム。マージソート・バブルソート・挿入ソートは安定。クイックソート・ヒープソート・選択ソートは一般に不安定。"
    },
    {
      "id": "ap_algo_013",
      "question": "フロイド-ワーシャル法の説明として適切なものはどれか？",
      "choices": [
        "単一始点の最短経路を求めるアルゴリズム",
        "全頂点対の最短経路をO(V³)で求める動的計画法アルゴリズム",
        "負の閉路を検出できない",
        "最小全域木を求めるアルゴリズム"
      ],
      "answer": 1,
      "explanation": "フロイド-ワーシャル法はDP（中継頂点kを経由するかしないかを比較）で全頂点対の最短経路をO(V³)で求める。負の辺にも対応し、負の閉路も検出できる。"
    },
    {
      "id": "ap_algo_014",
      "question": "計算量のO(1)で実現できる操作として適切なものはどれか？",
      "choices": [
        "線形探索",
        "2分探索",
        "配列の末尾への追加（動的配列を除く）",
        "バブルソート"
      ],
      "answer": 2,
      "explanation": "配列の末尾追加（インデックスが既知）はO(1)の定数時間操作。線形探索O(n)、2分探索O(log n)、バブルソートO(n²)。ハッシュテーブルの検索・挿入も平均O(1)。"
    },
    {
      "id": "ap_algo_015",
      "question": "トポロジカルソートが適用できるグラフの条件として適切なものはどれか？",
      "choices": [
        "無向グラフ",
        "サイクルのある有向グラフ",
        "有向非巡回グラフ（DAG）",
        "木構造のみ"
      ],
      "answer": 2,
      "explanation": "トポロジカルソートはDAG（Directed Acyclic Graph）にのみ適用可能。全ての辺u→vに対してuがvより前に来るように頂点を線形順序に並べる。タスクの依存関係解決・ビルドシステムなどに使用。"
    },
    {
      "id": "ap_algo_016",
      "question": "ブルームフィルタの特徴として適切なものはどれか？",
      "choices": [
        "false negativeが発生することがある",
        "false positiveが発生することがあるが、false negativeは発生しない",
        "要素の削除が簡単",
        "100%正確な存在確認が可能"
      ],
      "answer": 1,
      "explanation": "ブルームフィルタは確率的データ構造で、「存在しない」の判定は正確だがfalse positive（「存在しない」ものを「存在する」と判定）が発生する。メモリ効率が極めて高くスパムフィルタ・キャッシュなどに使用。"
    },
    {
      "id": "ap_algo_017",
      "question": "DP（動的計画法）の「ナップサック問題（0/1）」の計算量として適切なものはどれか？",
      "choices": [
        "O(n log n)",
        "O(n × W)（nは品物数、Wはナップサックの容量）",
        "O(2^n)",
        "O(n²)"
      ],
      "answer": 1,
      "explanation": "0/1ナップサック問題のDPは品物i（1〜n）ごとに容量w（0〜W）のDPテーブルを更新するためO(n×W)の擬似多項式時間アルゴリズム。完全解を求める問題としてはNP困難だが、DPで実用的な解が得られる。"
    },
    {
      "id": "ap_algo_018",
      "question": "赤黒木の特性として適切でないものはどれか？",
      "choices": [
        "各ノードは赤または黒",
        "根は黒",
        "全ての葉（NILノード）は黒",
        "赤いノードの子は必ず赤"
      ],
      "answer": 3,
      "explanation": "赤黒木の規則：①各ノードは赤か黒、②根は黒、③全葉（NIL）は黒、④赤ノードの子は必ず黒（連続する赤禁止）、⑤根から葉への全経路で黒ノード数が等しい。④は「赤の子は必ず黒」。"
    },
    {
      "id": "ap_algo_019",
      "question": "最長共通部分列（LCS）問題のDPアルゴリズムの計算量として適切なものはどれか？",
      "choices": [
        "O(n + m)",
        "O(n × m)",
        "O(n² + m²)",
        "O(2^n)"
      ],
      "answer": 1,
      "explanation": "LCS（Longest Common Subsequence）はDPで2次元テーブル（n×m）を埋めることでO(n×m)で解ける。diffコマンドや遺伝子配列比較など多くの場面で使用される古典的DP問題。"
    },
    {
      "id": "ap_algo_020",
      "question": "スキップリストの説明として適切なものはどれか？",
      "choices": [
        "ソートされた木構造データ",
        "確率的データ構造で複数レベルのリンクを持ちO(log n)の検索・挿入・削除を平均で実現する",
        "二分探索木の一種",
        "ハッシュテーブルの変形"
      ],
      "answer": 1,
      "explanation": "スキップリストはランダムなレベル割り当てで複数のリンクレイヤーを持つ連結リスト。平均O(log n)の操作をB木より単純な実装で実現。Redisのソート済みセットに採用されている。"
    },
    {
      "id": "ap_algo_021",
      "question": "ビット演算を使った効率的な処理として適切でないものはどれか？",
      "choices": [
        "2の累乗の乗算（左シフト）",
        "2の累乗の除算（右シフト）",
        "偶奇判定（AND 1）",
        "文字列の連結"
      ],
      "answer": 3,
      "explanation": "ビット演算：左シフト（n<<k）は2^k倍、右シフト（n>>k）は2^k除算（整数）、AND 1で最下位ビット確認（偶奇判定）。文字列連結はビット演算で効率化できない。"
    },
    {
      "id": "ap_algo_022",
      "question": "フェニック木（BIT: Binary Indexed Tree）の主な用途として適切なものはどれか？",
      "choices": [
        "グラフのトポロジカルソート",
        "配列の区間和クエリと点更新をO(log n)で処理する",
        "グラフの最短経路計算",
        "文字列のパターンマッチング"
      ],
      "answer": 1,
      "explanation": "フェニック木はビット演算を利用した効率的なデータ構造で、点更新とプレフィックス和クエリをO(log n)で処理できる。セグメント木より単純な実装でメモリ効率も高い。"
    },
    {
      "id": "ap_algo_023",
      "question": "貪欲法（グリーディアルゴリズム）が最適解を保証する問題として適切なものはどれか？",
      "choices": [
        "0/1ナップサック問題",
        "分数ナップサック問題",
        "巡回セールスマン問題",
        "部分和問題"
      ],
      "answer": 1,
      "explanation": "分数ナップサック問題は物品を分割できるため、単価（価値/重量）の高い順に詰めるグリーディで最適解が得られる。0/1ナップサックは物品を分割できないためDPが必要でグリーディでは最適解が保証されない。"
    },
    {
      "id": "ap_algo_024",
      "question": "セグメント木の主な用途として適切なものはどれか？",
      "choices": [
        "グラフのDFS順序付け",
        "区間クエリ（区間最小値・最大値・合計）と点更新をO(log n)で処理する",
        "文字列のソート",
        "二分探索"
      ],
      "answer": 1,
      "explanation": "セグメント木は配列の区間演算（最小・最大・合計・GCDなど）と点更新をO(log n)で処理できるデータ構造。競技プログラミングや範囲検索問題で広く使用される。"
    },
    {
      "id": "ap_algo_025",
      "question": "モンテカルロ法の説明として適切なものはどれか？",
      "choices": [
        "確定的アルゴリズムで厳密な解を求める",
        "乱数を使ったシミュレーションで確率的に近似解を求める",
        "グラフの確率的探索",
        "ハッシュ関数の乱数化手法"
      ],
      "answer": 1,
      "explanation": "モンテカルロ法は乱数を使ったサンプリングで積分・最適化・シミュレーションなどの近似解を求める。標本数が増えるほど精度が向上する。円周率の近似計算が有名な例。"
    },
    {
      "id": "ap_algo_026",
      "question": "FFT（高速フーリエ変換）の計算量として適切なものはどれか？",
      "choices": [
        "O(n²)",
        "O(n log n)",
        "O(n)",
        "O(log n)"
      ],
      "answer": 1,
      "explanation": "FFTはDFT（離散フーリエ変換）をO(n²)からO(n log n)に高速化したアルゴリズム。信号処理・画像処理・多項式乗算（ビッグ整数の乗算など）で使用される。"
    },
    {
      "id": "ap_algo_027",
      "question": "オイラーツアー（Euler Tour）の説明として適切なものはどれか？",
      "choices": [
        "グラフの最短経路",
        "グラフの全辺を1度ずつ通る閉路（オイラー回路）の探索",
        "グラフの全頂点を1度ずつ訪問する回路",
        "最小全域木の探索"
      ],
      "answer": 1,
      "explanation": "オイラー回路（全辺を一度通る閉路）の存在条件：無向グラフは全頂点の次数が偶数、有向グラフは全頂点で入次数=出次数。ハミルトン路（全頂点を一度訪問）はNP完全で別問題。"
    },
    {
      "id": "ap_algo_028",
      "question": "確率的プライマリティテスト「ミラー-ラビン素数判定法」の特徴として適切なものはどれか？",
      "choices": [
        "100%の正確さで素数を判定できる",
        "合成数を誤って素数と判定するfalse positiveが非常に低い確率で発生する",
        "計算量が非常に大きい",
        "小さな数にしか適用できない"
      ],
      "answer": 1,
      "explanation": "ミラー-ラビン法は確率的素数判定アルゴリズムで、k回のランダムな証人を使って検査する。false negative（素数を合成数と判定）はなく、false positive確率は4^(-k)以下と極めて低い。RSA鍵生成に使用される。"
    },
    {
      "id": "ap_algo_029",
      "question": "座標圧縮の説明として適切なものはどれか？",
      "choices": [
        "座標を圧縮してメモリを節約する",
        "大きな座標の値を相対的な小さな値に変換し、不要な空間を排除して問題を解きやすくする",
        "データを3次元から2次元に変換する",
        "座標をビット演算で圧縮する"
      ],
      "answer": 1,
      "explanation": "座標圧縮は実際の座標値が大きくても使用する値の種類数が少ない場合に、出現する値のみに圧縮してインデックス化する手法。セグメント木などのデータ構造の適用範囲を拡大するために使用。"
    },
    {
      "id": "ap_algo_030",
      "question": "二分探索の前提条件として適切なものはどれか？",
      "choices": [
        "データが重複なく格納されていること",
        "探索対象が整列（ソート）されていること",
        "データ数が偶数であること",
        "ランダムアクセス可能なデータ構造で格納されていること"
      ],
      "answer": 1,
      "explanation": "二分探索はソート済み配列で中央値と比較して探索範囲を半分に絞るO(log n)のアルゴリズム。ランダムアクセスが必要なため連結リストには直接適用できない（インデックスアクセスが必要）。"
    }
  ]
}