{
  "genre": "データベース",
  "exam": "応用情報技術者試験",
  "category": "ap_db",
  "questions": [
    {
      "id": "ap_db_001",
      "question": "正規化の第3正規形（3NF）の条件として適切なものはどれか？",
      "choices": [
        "主キー以外の属性間に関数従属がない",
        "非キー属性が主キーの一部に関数従属している",
        "主キーに重複がない",
        "テーブルに複合主キーが存在しない"
      ],
      "answer": 0,
      "explanation": "第3正規形は第2正規形を満たし、かつ非キー属性から別の非キー属性への推移的関数従属（非キー属性→非キー属性）を排除したもの。"
    },
    {
      "id": "ap_db_002",
      "question": "トランザクションのACID特性における「独立性（Isolation）」の説明として適切なものはどれか？",
      "choices": [
        "トランザクションの処理結果は永続的に保持される",
        "複数のトランザクションが同時実行されても互いに干渉しない",
        "トランザクションの処理は全て完了するか全て取り消される",
        "データは常に整合性のある状態に保たれる"
      ],
      "answer": 1,
      "explanation": "独立性（Isolation）は同時実行される複数のトランザクションが互いに影響を与えないことを保証。分離レベル（Read Uncommitted/Read Committed/Repeatable Read/Serializable）で制御される。"
    },
    {
      "id": "ap_db_003",
      "question": "ファントムリードが発生する分離レベルとして適切なものはどれか？",
      "choices": [
        "Serializable",
        "Repeatable Read",
        "Read Committed",
        "Read Uncommitted"
      ],
      "answer": 1,
      "explanation": "Repeatable Readでは自分のトランザクション中に読み取った行は変更されないが、他のトランザクションが新しい行を挿入すると、同じ検索で異なる行数が返る「ファントムリード」が発生する。"
    },
    {
      "id": "ap_db_004",
      "question": "B+木インデックスの特徴として適切なものはどれか？",
      "choices": [
        "葉ノードにのみデータへのポインタが格納され、リーフノードがリスト構造で連結される",
        "全てのノードにデータが格納される",
        "バランスが保証されないため最悪ケースの検索が遅い",
        "ハッシュテーブルを使用したインデックス"
      ],
      "answer": 0,
      "explanation": "B+木は全データが葉ノードにあり葉ノードはリンクリストで連結されているため範囲検索に優れる。内部ノードは検索キーのみを保持。"
    },
    {
      "id": "ap_db_005",
      "question": "SQLのウィンドウ関数（OVER句）の説明として適切なものはどれか？",
      "choices": [
        "テーブルを結合するための関数",
        "GROUP BYと同様に行をグループに集約する",
        "集約せずに行ごとに集計結果を計算できる",
        "サブクエリの別名を定義する"
      ],
      "answer": 2,
      "explanation": "ウィンドウ関数はROW_NUMBER()、RANK()、SUM() OVER()などを使用し、行を集約せず各行に対してウィンドウ（範囲）内の集計結果を返す。"
    },
    {
      "id": "ap_db_006",
      "question": "デッドロックの説明として適切なものはどれか？",
      "choices": [
        "1つのトランザクションが無限ループする状態",
        "複数のトランザクションが互いに相手のロックを待ち合って永久に進行できない状態",
        "データベースのディスク容量が不足した状態",
        "インデックスの破損によりクエリが完了できない状態"
      ],
      "answer": 1,
      "explanation": "デッドロックは複数のトランザクションがそれぞれ相手が保持するリソースのロック解放を待ち合うことで処理が永久に停止する状態。タイムアウトや優先度付きで一方をアボートして解決する。"
    },
    {
      "id": "ap_db_007",
      "question": "WAL（Write-Ahead Logging）の目的として適切なものはどれか？",
      "choices": [
        "データ更新前にジャーナルに記録することでクラッシュ時のデータ復旧を可能にする",
        "クエリの実行計画をキャッシュして高速化する",
        "インデックスを事前に更新してデータの整合性を保つ",
        "バックアップの自動化を実現する"
      ],
      "answer": 0,
      "explanation": "WALはデータを実際のデータファイルに書き込む前にトランザクションログに記録する手法。クラッシュ時にログを使ってロールフォワード（REDOログ）またはロールバック（UNDOログ）でデータを復旧する。"
    },
    {
      "id": "ap_db_008",
      "question": "水平分割（シャーディング）の説明として適切なものはどれか？",
      "choices": [
        "テーブルの列を複数のテーブルに分割する",
        "テーブルの行を複数のデータベースに分散させる",
        "テーブルの主キーを変更する",
        "インデックスを複数のファイルに分割する"
      ],
      "answer": 1,
      "explanation": "シャーディング（水平分割）はテーブルの行を複数のサーバ・DBに分散してスケールアウトを実現する手法。分散キーの選択が重要でJOINや集計が複雑になる。"
    },
    {
      "id": "ap_db_009",
      "question": "MVCC（Multi-Version Concurrency Control）の説明として適切なものはどれか？",
      "choices": [
        "排他ロックを使って同時実行を制御する手法",
        "データの旧バージョンを保持することで読み取り操作をブロックせずに一貫性を確保する",
        "トランザクションを直列化して実行する手法",
        "インデックスを複数バージョン管理する手法"
      ],
      "answer": 1,
      "explanation": "MVCCはデータの更新時に旧バージョンを保持し、読み取りは書き込みをブロックせず一貫したスナップショットを参照する。PostgreSQL、MySQL（InnoDB）、Oracleで採用。"
    },
    {
      "id": "ap_db_010",
      "question": "SQLインジェクション対策として最も効果的なものはどれか？",
      "choices": [
        "入力値の文字数制限",
        "プリペアドステートメント（パラメータ化クエリ）の使用",
        "HTMLエンコーディング",
        "ファイアウォールの設置"
      ],
      "answer": 1,
      "explanation": "プリペアドステートメントはSQL文の構造を事前にコンパイルし、入力値をパラメータとして後から渡すことでSQLとして解釈されず最も効果的なSQLインジェクション対策となる。"
    },
    {
      "id": "ap_db_011",
      "question": "列指向データベースの特徴として適切なものはどれか？",
      "choices": [
        "OLTP処理に最適化されている",
        "列単位でデータを格納し分析クエリ（OLAP）に優れる",
        "行単位でデータを格納する",
        "トランザクション処理が行指向より高速"
      ],
      "answer": 1,
      "explanation": "列指向DB（ColumnarDB）は同一列のデータを連続格納するため、特定列の集計・集約クエリが高速でOLAPに向く。RedshiftやBigQueryなどのDWHで使用される。"
    },
    {
      "id": "ap_db_012",
      "question": "CAP定理の説明として適切なものはどれか？",
      "choices": [
        "分散システムはConsistency・Availability・Partition toleranceを同時に全て満たすことができない",
        "RDBMSはACID特性を全て同時に満たせない",
        "クラウドDBは可用性と一貫性を両立できる",
        "NoSQLはPartition toleranceを犠牲にする"
      ],
      "answer": 0,
      "explanation": "CAP定理（ブルワーの定理）は分散システムにおいて「一貫性（C）・可用性（A）・分断耐性（P）」の3つを同時に全て保証することは不可能であることを示す定理。"
    },
    {
      "id": "ap_db_013",
      "question": "グラフデータベースの適用に最も適したユースケースはどれか？",
      "choices": [
        "大量のトランザクション処理",
        "SNSの友人関係・レコメンデーション・知識グラフなど関係性の複雑なデータ管理",
        "時系列データの高速書き込み",
        "非構造化テキストデータの全文検索"
      ],
      "answer": 1,
      "explanation": "グラフDBはノード（頂点）とエッジ（辺）でデータを表現し、ネットワーク状の関係性クエリ（最短経路、近傍探索など）に優れる。Neo4jが代表的。"
    },
    {
      "id": "ap_db_014",
      "question": "データウェアハウスのスタースキーマの特徴として適切なものはどれか？",
      "choices": [
        "全テーブルが等価に結合される",
        "ファクトテーブルを中心にディメンションテーブルが放射状に配置される",
        "正規化を徹底してデータ冗長性を排除する",
        "トランザクション処理に最適化されたスキーマ"
      ],
      "answer": 1,
      "explanation": "スタースキーマはファクトテーブル（売上など測定値）を中心に、非正規化されたディメンションテーブル（日付・商品・顧客など）が結合される構造。OLAPに向く。"
    },
    {
      "id": "ap_db_015",
      "question": "データベースのカーディナリティの説明として適切なものはどれか？",
      "choices": [
        "テーブルの行数",
        "列内の一意な値の種類数",
        "テーブル間の関係の多重度（1対多など）",
        "インデックスの深さ"
      ],
      "answer": 1,
      "explanation": "カーディナリティは列内のユニークな値の数（多様性）のこと。カーディナリティが高い列（ほぼ一意）はインデックスの効果が大きく、低い列（性別など）は効果が小さい。※テーブル間の多重度もカーディナリティと呼ぶ場合あり。"
    },
    {
      "id": "ap_db_016",
      "question": "JSONBとJSONのPostgreSQLでの違いとして適切なものはどれか？",
      "choices": [
        "JSONBは文字列として格納されJSONはバイナリで格納される",
        "JSONBはバイナリ形式で格納され検索・インデックスに優れ、JSONはテキストそのまま格納される",
        "JSONBはJSON標準に準拠していない",
        "JSONBはトランザクションをサポートしない"
      ],
      "answer": 1,
      "explanation": "PostgreSQLのJSONBはバイナリ形式で格納され、GINインデックスを使った高速検索が可能。JSONは入力テキストをそのまま格納するため書き込みは速いが検索は遅い。"
    },
    {
      "id": "ap_db_017",
      "question": "ストアドプロシージャのメリットとして適切でないものはどれか？",
      "choices": [
        "ネットワーク通信量の削減",
        "データベースサーバでロジックを実行することによる高速化",
        "アプリケーション間でロジックを共有できる",
        "異なるDBMSへの移植性が高い"
      ],
      "answer": 3,
      "explanation": "ストアドプロシージャはDBMS固有の構文で記述されるため、異なるDBMS（Oracle→PostgreSQLなど）への移植性は低い。これがデメリットの一つ。"
    },
    {
      "id": "ap_db_018",
      "question": "データベースの楽観的排他制御の説明として適切なものはどれか？",
      "choices": [
        "処理開始時にロックを取得して他のトランザクションをブロックする",
        "データ取得時はロックせず、更新時にバージョン番号などで競合を検出する",
        "デッドロックを完全に防止できる",
        "常に悲観的排他制御より高性能である"
      ],
      "answer": 1,
      "explanation": "楽観的排他制御は「競合はまれ」と想定してロック無しで読み取り、更新時にバージョン番号やタイムスタンプで競合を検出。競合時はロールバックしてリトライする。"
    },
    {
      "id": "ap_db_019",
      "question": "全文検索インデックスの転置インデックスの説明として適切なものはどれか？",
      "choices": [
        "主キーの値を転置してインデックスを作成する",
        "単語からその単語を含む文書のリストへのマッピングを持つインデックス",
        "B木インデックスを逆順に並べたもの",
        "テーブルの行を列方向に転置して格納する"
      ],
      "answer": 1,
      "explanation": "転置インデックスは各単語（トークン）をキーとして、その単語を含む文書IDと出現位置のリストをマッピングした構造。全文検索エンジン（Elasticsearch、Luceneなど）の基盤技術。"
    },
    {
      "id": "ap_db_020",
      "question": "ETL処理の説明として適切なものはどれか？",
      "choices": [
        "データのバックアップと復元プロセス",
        "異なるソースからデータを抽出・変換・ロードしてDWHに格納するプロセス",
        "トランザクションのコミットとロールバック",
        "インデックスの再構築プロセス"
      ],
      "answer": 1,
      "explanation": "ETL（Extract・Transform・Load）はデータソースからデータを抽出（E）し、クレンジング・変換（T）を行い、DWH・データマートに格納（L）するデータ統合プロセス。"
    },
    {
      "id": "ap_db_021",
      "question": "データベースのパーティショニングのメリットして適切でないものはどれか？",
      "choices": [
        "クエリのパフォーマンス向上（パーティションプルーニング）",
        "データ管理（削除・アーカイブ）の効率化",
        "JOINクエリの完全な高速化",
        "大規模テーブルの並列スキャン"
      ],
      "answer": 2,
      "explanation": "パーティショニングはJOINを高速化するためのものではなく、異なるパーティションをJOINする場合はオーバーヘッドが増える場合もある。"
    },
    {
      "id": "ap_db_022",
      "question": "データベースのヒープ領域の説明として適切なものはどれか？",
      "choices": [
        "インデックスを格納する領域",
        "テーブルデータが順序なく格納されるデフォルトの格納構造",
        "ソート作業に使用する一時領域",
        "ログを格納する領域"
      ],
      "answer": 1,
      "explanation": "ヒープはデータを特定の順序なく格納するデフォルトのテーブル構造。行の追加は末尾に行われ、削除されたスペースに再利用される。クラスタ化インデックスとは対比される概念。"
    },
    {
      "id": "ap_db_023",
      "question": "PostgreSQLのVACUUMの目的として適切なものはどれか？",
      "choices": [
        "インデックスを最適化する",
        "MVCCで残された不要な旧バージョン行（デッドタプル）を回収して空間を再利用する",
        "統計情報を更新する",
        "接続プールを最適化する"
      ],
      "answer": 1,
      "explanation": "PostgreSQLのMVCCは更新・削除時に旧バージョンを残すためデッドタプルが蓄積する。VACUUMはこれを回収して空き領域を再利用可能にする。VACUUM ANALYZEは統計情報も更新する。"
    },
    {
      "id": "ap_db_024",
      "question": "リレーショナルデータベースの関係代数における「選択（Selection）」の説明として適切なものはどれか？",
      "choices": [
        "テーブルから特定の列を取り出す操作",
        "テーブルから条件を満たす行を取り出す操作",
        "2つのテーブルを結合する操作",
        "テーブルの行を並べ替える操作"
      ],
      "answer": 1,
      "explanation": "関係代数の選択（σ）は条件を満たす行（タプル）を取り出す操作。SQLのWHERE句に対応。投影（π）は列を取り出す操作でSELECT句に対応。"
    },
    {
      "id": "ap_db_025",
      "question": "NewSQLデータベースの特徴として適切なものはどれか？",
      "choices": [
        "NoSQLと同様にACIDを保証しない",
        "RDBMSのACID特性を保ちながらNoSQL並みのスケーラビリティを実現する",
        "列指向のデータ格納形式を採用する",
        "グラフ構造のデータモデルを採用する"
      ],
      "answer": 1,
      "explanation": "NewSQLはSpannerやCockroachDBなどに代表される、従来RDBMSのACID保証とNoSQLのスケーラビリティを両立させた次世代の分散RDB。"
    },
    {
      "id": "ap_db_026",
      "question": "オブジェクト指向データベース（OODB）の特徴として適切なものはどれか？",
      "choices": [
        "テーブルとレコードでデータを表現する",
        "オブジェクト・継承・多態性などOO概念をネイティブに扱い、インピーダンスミスマッチを解消する",
        "グラフ構造でデータを格納する",
        "NoSQLデータベースの一種である"
      ],
      "answer": 1,
      "explanation": "OODBはオブジェクト・クラス・継承・カプセル化などのOO概念をDBレベルでサポートし、O/Rマッピングが不要。CAD・CAMなど複雑オブジェクトに向く。"
    },
    {
      "id": "ap_db_027",
      "question": "データベースのチェックポイントの目的として適切なものはどれか？",
      "choices": [
        "定期的にバックアップを取得する",
        "ログのREDO範囲を短縮してリカバリ時間を短縮する",
        "インデックスを更新する",
        "統計情報を収集する"
      ],
      "answer": 1,
      "explanation": "チェックポイントはその時点のバッファキャッシュをディスクに書き出しログの起点を記録する処理。障害時のリカバリでREDO（ロールフォワード）が必要な範囲をチェックポイント以降に限定できる。"
    },
    {
      "id": "ap_db_028",
      "question": "データディクショナリ（システムカタログ）に格納される情報として適切なものはどれか？",
      "choices": [
        "実際のテーブルデータ",
        "テーブル定義・インデックス・制約・権限などDBのメタデータ",
        "トランザクションログ",
        "バックアップデータ"
      ],
      "answer": 1,
      "explanation": "データディクショナリ（システムカタログ）はDBMSが管理するメタデータの集合で、テーブル・列・インデックス・制約・ユーザ権限・統計情報などが格納されている。"
    },
    {
      "id": "ap_db_029",
      "question": "データベースの「ロールフォワード」の説明として適切なものはどれか？",
      "choices": [
        "トランザクションを取り消してコミット前の状態に戻す",
        "バックアップからリストア後にREDOログを適用して障害直前の状態に回復する",
        "インデックスを再構築する",
        "データを前のバージョンに戻す"
      ],
      "answer": 1,
      "explanation": "ロールフォワード（REDO）はバックアップポイント以降にコミット済みのトランザクションをREDOログを使って再適用し、障害直前の状態まで回復する処理。"
    },
    {
      "id": "ap_db_030",
      "question": "データレイクの特徴として適切なものはどれか？",
      "choices": [
        "厳格なスキーマを定義した後にのみデータ格納が可能",
        "構造化・非構造化を問わず生データを低コストストレージに大量格納し必要時に変換・分析する",
        "OLTPに特化したシステム",
        "データウェアハウスと同義"
      ],
      "answer": 1,
      "explanation": "データレイクはスキーマを事前定義せず（スキーマオンリード）、S3などのオブジェクトストレージに生データを大量格納し、分析時に必要な形式に変換する。DWH（スキーマオンライト）と対比される。"
    }
  ]
}