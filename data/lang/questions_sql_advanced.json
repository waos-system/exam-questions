{
  "genre": "高度なSQL・最適化",
  "exam": "SQL",
  "questions": [
    {
      "id": "sql_advanced_001",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "EXPLAIN コマンドの主な役割は何か？",
      "options": {
        "A": "クエリを実行してその結果を表示する",
        "B": "クエリの実行計画を表示して最適化を支援する",
        "C": "テーブル構造を表示する",
        "D": "データベース内のすべてのインデックスを列挙する"
      },
      "correct": "B",
      "explanation": "EXPLAIN（または EXPLAIN ANALYZE）は、SQLクエリの実行計画を表示します。これにより、クエリエンジンがどのようにクエリを実行するかを理解し、パフォーマンスの最適化に役立てることができます。"
    },
    {
      "id": "sql_advanced_002",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "EXPLAIN ANALYZE と EXPLAIN の違いは何か？",
      "options": {
        "A": "EXPLAIN ANALYZE はクエリを実行して実際の実行時間を表示し、EXPLAIN は実行計画のみを表示",
        "B": "EXPLAIN ANALYZE はクエリを実行しない",
        "C": "EXPLAINはPostgreSQLのみで、EXPLAIN ANALYZEは全DBMSで使用可能",
        "D": "機能的に違いはない"
      },
      "correct": "A",
      "explanation": "EXPLAIN は実行計画を表示するだけでクエリを実行しません。EXPLAIN ANALYZE はクエリを実行して、実際の実行行数・実行時間などを表示します。パフォーマンス分析に EXPLAIN ANALYZE が使用されます。"
    },
    {
      "id": "sql_advanced_003",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "基礎",
      "question": "インデックスの主な目的は何か？",
      "options": {
        "A": "クエリの実行速度を向上させる",
        "B": "ディスク容量を削減する",
        "C": "データの整合性を保証する",
        "D": "ネットワーク接続を改善する"
      },
      "correct": "A",
      "explanation": "インデックスは、テーブル内のデータを高速に検索するための構造です。特に WHERE 句や JOIN、ORDER BY で使用される列にインデックスを作成することで、スキャン時間を大幅に削減できます。"
    },
    {
      "id": "sql_advanced_004",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "複合インデックス（Composite Index）の列の順序が重要とされる理由は何か？",
      "options": {
        "A": "メモリ使用量が影響される",
        "B": "インデックスの有効利用がされたかがクエリの WHERE 句の列の順序に依存するため",
        "C": "ディスク上の物理的な順序が決まる",
        "D": "INSERT/UPDATE パフォーマンスに影響するため"
      },
      "correct": "B",
      "explanation": "複合インデックスでは列の順序が大切です。クエリの WHERE 句で使用される列の順序と、複合インデックスの列の順序が合致しないと、インデックスが有効に使用されない可能性があります。"
    },
    {
      "id": "sql_advanced_005",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "B-Tree インデックスとハッシュインデックスの主な違いは何か？",
      "options": {
        "A": "B-Tree は範囲検索が可能で、ハッシュインデックスは完全一致検索のみ",
        "B": "ハッシュインデックスは範囲検索が可能で、B-Tree は完全一致検索のみ",
        "C": "機能的に違いはない",
        "D": "B-Tree はメモリを節約し、ハッシュインデックスは速度が速い"
      },
      "correct": "A",
      "explanation": "B-Tree インデックスは順序付けされており、範囲検索（BETWEEN、<、>など）に対応します。ハッシュインデックスは高速な完全一致検索に適していますが、範囲検索には不向きです。"
    },
    {
      "id": "sql_advanced_006",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "クエリパフォーマンスを診断する際に、実行計画内の \"Seq Scan\" の意味は？",
      "options": {
        "A": "テーブルの一部だけをスキャンしている",
        "B": "テーブル全体のシーケンシャルスキャンを実行している",
        "C": "インデックスを使用した高速スキャン",
        "D": "並列スキャンを実行している"
      },
      "correct": "B",
      "explanation": "Seq Scan（シーケンシャルスキャン）はテーブルの全行をスキャンすることを意味します。インデックスが使用されていない状態で、大規模データセットではパフォーマンスの低下につながります。"
    },
    {
      "id": "sql_advanced_007",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "基礎",
      "question": "トランザクション（Transaction）の ACID 特性について、A は何を表すか？",
      "options": {
        "A": "Allocation（割り当て）",
        "B": "Atomicity（原子性）",
        "C": "Assignment（割り当て）",
        "D": "Authenticity（認証性）"
      },
      "correct": "B",
      "explanation": "A は Atomicity を表します。これはトランザクション内のすべての操作が一つの単位として実行され、全て成功するかすべて失敗するか、のいずれかであることを意味します。"
    },
    {
      "id": "sql_advanced_008",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "基礎",
      "question": "ACID 特性の C は何を表すか？",
      "options": {
        "A": "Consistency（一貫性）",
        "B": "Completeness（完全性）",
        "C": "Concurrency（並行性）",
        "D": "Compatibility（互換性）"
      },
      "correct": "A",
      "explanation": "C は Consistency を表します。トランザクション前後で、データベースが一貫性のある状態を保つことを意味します。"
    },
    {
      "id": "sql_advanced_009",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "基礎",
      "question": "ACID 特性の I は何を表すか？",
      "options": {
        "A": "Index（インデックス）",
        "B": "Integrity（整合性）",
        "C": "Isolation（分離性）",
        "D": "Implementation（実装）"
      },
      "correct": "C",
      "explanation": "I は Isolation を表します。複数のトランザクションが同時に実行される場合、一つのトランザクションの操作が他のトランザクションに影響を与えないことを意味します。"
    },
    {
      "id": "sql_advanced_010",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "基礎",
      "question": "ACID 特性の D は何を表すか？",
      "options": {
        "A": "Durability（永続性）",
        "B": "Distribution（分散性）",
        "C": "Declaration（宣言）",
        "D": "Delivery（配送）"
      },
      "correct": "A",
      "explanation": "D は Durability を表します。コミットされたトランザクションのデータは、システム障害やクラッシュが発生しても永続的に保存されることを意味します。"
    },
    {
      "id": "sql_advanced_011",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "トランザクション分離レベルの \"READ UNCOMMITTED\" について、最も正確な説明はどれか？",
      "options": {
        "A": "最も厳密で、他のトランザクションがコミット前のデータを読み取ることができない",
        "B": "最も低い分離レベルで、ダーティリードが発生する可能性がある",
        "C": "デフォルト分離レベル",
        "D": "インデックスを使用しない読み取り"
      },
      "correct": "B",
      "explanation": "READ UNCOMMITTED は最も低い分離レベルで、コミット前のデータを読み取るダーティリード（Dirty Read）が発生する可能性があり、データの正確性が損なわれるリスクがあります。"
    },
    {
      "id": "sql_advanced_012",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "トランザクション分離レベルの \"READ COMMITTED\" について、正しい説明はどれか？",
      "options": {
        "A": "ダーティリードは防ぐが、ファントムリードは発生する可能性がある",
        "B": "すべてのアノマリが防ぐ",
        "C": "最も低い分離レベル",
        "D": "インデックスを必須とする"
      },
      "correct": "A",
      "explanation": "READ COMMITTED はコミット済みのデータのみを読み取るため、ダーティリードは防ぎます。しかし、non-repeatable read やファントムリードは発生する可能性があります。"
    },
    {
      "id": "sql_advanced_013",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "トランザクション分離レベルの \"REPEATABLE READ\" について、最も正確な説明はどれか？",
      "options": {
        "A": "同じ行を複数回読み取るときに同じ値を保証する",
        "B": "ファントムリードが発生しない",
        "C": "すべてのアノマリが防ぐ",
        "D": "パフォーマンスが最も良い分離レベル"
      },
      "correct": "A",
      "explanation": "REPEATABLE READ ではトランザクション中に同じ行を複数回読み取る場合、常に同じ値を取得することが保証されます。ただし、ファントムリードは発生する可能性があります。"
    },
    {
      "id": "sql_advanced_014",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "トランザクション分離レベルの \"SERIALIZABLE\" について、最も正確な説明はどれか？",
      "options": {
        "A": "複数のトランザクションを順番に実行するレベル",
        "B": "最も高い分離レベルで、すべてのアノマリが防ぐ",
        "C": "パフォーマンスが最も良い",
        "D": "デフォルト分離レベル"
      },
      "correct": "B",
      "explanation": "SERIALIZABLE は最も高い分離レベルで、複数のトランザクションが順序付けされて実行されるように見え、ダーティリード、non-repeatable read、ファントムリードなど、すべてのアノマリが防がれます。"
    },
    {
      "id": "sql_advanced_015",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "ロック（Lock）メカニズムの主な役割は何か？",
      "options": {
        "A": "複数のトランザクションが同時にデータにアクセスするときの競合を防ぐ",
        "B": "ネットワーク接続を管理する",
        "C": "インデックスのメモリ使用量を制御する",
        "D": "クエリの実行速度を向上させる"
      },
      "correct": "A",
      "explanation": "ロックメカニズムは、複数のトランザクションが同じデータに同時にアクセスするときに、データの整合性を保つために競合を防ぎます。"
    },
    {
      "id": "sql_advanced_016",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "\"Shared Lock\" と \"Exclusive Lock\" の主な違いは何か？",
      "options": {
        "A": "Shared Lock は読み取り専用で、複数トランザクションが同時に保持可能。Exclusive Lock は書き込み用で単一トランザクションのみ",
        "B": "Exclusive Lock は読み取り専用で、Shared Lock は書き込み用",
        "C": "機能的に違いはない",
        "D": "Shared Lock はテーブルレベル、Exclusive Lock は行レベル"
      },
      "correct": "A",
      "explanation": "Shared Lock (読み取りロック)は複数のトランザクションが同時に保持でき、Exclusive Lock (排他ロック)は単一のトランザクションのみが保持できます。"
    },
    {
      "id": "sql_advanced_017",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "デッドロック（Deadlock）が発生する最も一般的な原因は何か？",
      "options": {
        "A": "不十分なメモリ",
        "B": "複数のトランザクションが異なる順序でリソースをロックしようとする",
        "C": "インデックスが不足している",
        "D": "ネットワーク遅延"
      },
      "correct": "B",
      "explanation": "デッドロックは、トランザクション A がリソース X をロックしてリソース Y をロック待ち、トランザクション B がリソース Y をロックしてリソース X をロック待ちといった循環的な待ち状態で発生します。"
    },
    {
      "id": "sql_advanced_018",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "クエリ実行計画内の \"Cost\" パラメータが表すものは何か？",
      "options": {
        "A": "実際のMB単位のディスク容量",
        "B": "推定されるリソース消費量（ディスクアクセス、CPU 計算など）",
        "C": "実行にかかる秒単位の時間",
        "D": "ディスクメモリの使用率"
      },
      "correct": "B",
      "explanation": "Cost は推定されるリソース消費量の指標で、より低い Cost を持つ実行計画の方が効率的であると考えられます。"
    },
    {
      "id": "sql_advanced_019",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "基礎",
      "question": "WITH 句（CTE）の主な利点は何か？",
      "options": {
        "A": "ディスク容量を節約する",
        "B": "複雑なクエリを読みやすくし、サブクエリを名前付けできる",
        "C": "インデックスを自動的に作成する",
        "D": "ネットワーク帯域幅を改善する"
      },
      "correct": "B",
      "explanation": "WITH 句（Common Table Expression）はサブクエリに名前を付けることで、複雑なクエリを読みやすく、保守しやすくします。再利用可能な一時的な結果セットを定義できます。"
    },
    {
      "id": "sql_advanced_020",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "再帰的 CTE（Recursive CTE）の典型的な使用例はどれか？",
      "options": {
        "A": "複数のテーブルへの単純な結合",
        "B": "階層的なデータ構造（組織図、カテゴリツリーなど）のクエリ",
        "C": "単純な WHERE フィルタリング",
        "D": "データの集計"
      },
      "correct": "B",
      "explanation": "再帰的 CTE は、階層的なデータを反復的に処理する場合に使用されます。例えば、従業員の上司チェーンや、カテゴリの親子関係などの処理に適しています。"
    },
    {
      "id": "sql_advanced_021",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "テーブル統計（Table Statistics）の主な役割は何か？",
      "options": {
        "A": "クエリオプティマイザが最適な実行計画を選択するための情報を提供する",
        "B": "ディスク使用量を自動的に削減する",
        "C": "ロック競合を防ぐ",
        "D": "ネットワーク接続を改善する"
      },
      "correct": "A",
      "explanation": "テーブル統計は、行数、列の値の分布、NULL率などの情報を含み、クエリオプティマイザが最適な実行計画を選択するために使用されます。"
    },
    {
      "id": "sql_advanced_022",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "ANALYZE コマンド（統計更新）を定期的に実行する必要がある理由は何か？",
      "options": {
        "A": "新しいインデックスを作成するため",
        "B": "テーブルの統計情報を更新して、クエリオプティマイザが正確な実行計画を選択できるようにするため",
        "C": "データベースのバックアップを作成するため",
        "D": "ロック競合を解決するため"
      },
      "correct": "B",
      "explanation": "ANALYZE コマンドはテーブルの最新の統計情報を更新します。データが大幅に変更された場合、古い統計情報に基づいた不適切な実行計画が選択される可能性があるため、定期的に実行することが重要です。"
    },
    {
      "id": "sql_advanced_023",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "ビューテーブル（View）の主な利点は何か？",
      "options": {
        "A": "クエリパフォーマンスを自動的に向上させる",
        "B": "複雑なクエリを一度定義して、再利用可能にし、セキュリティを強化できる",
        "C": "ディスク容量を効率的に使用する",
        "D": "ロック競合を完全に排除する"
      },
      "correct": "B",
      "explanation": "ビューは複雑なクエリを一度定義して保存し、複数の場所で再利用できます。また、ユーザーに限定されたカラムのみを表示することで、セキュリティを強化できます。"
    },
    {
      "id": "sql_advanced_024",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "マテリアライズドビュー（Materialized View）と通常のビューの主な違いは何か？",
      "options": {
        "A": "マテリアライズドビューは物理的にデータを保存し、通常のビューはクエリ定義のみを保存",
        "B": "機能的に違いはない",
        "C": "通常のビューは高速で、マテリアライズドビューは遅い",
        "D": "マテリアライズドビューはPostgreSQLのみで使用可能"
      },
      "correct": "A",
      "explanation": "マテリアライズドビューは実際のデータを物理的に保存するため、クエリが高速で、複雑な集計に適しています。通常のビューはクエリ定義のみで、毎回基本テーブルをアクセスします。"
    },
    {
      "id": "sql_advanced_025",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "パーティショニング（Partitioning）の主な目的は何か？",
      "options": {
        "A": "自動的にデータをバックアップする",
        "B": "大規模テーブルを複数の物理的なテーブルに分割してパフォーマンスを向上させ、管理を容易にする",
        "C": "インデックスを自動的に最適化する",
        "D": "ネットワーク接続を改善する"
      },
      "correct": "B",
      "explanation": "パーティショニングは大規模テーブルをより小さな物理的な部分に分割することで、クエリが処理すべきデータセットを減らし、パフォーマンスを向上させます。保守性も向上します。"
    },
    {
      "id": "sql_advanced_026",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "パーティショニングの\"Range パーティショニング\"の主な使用例はどれか？",
      "options": {
        "A": "ハッシュ値に基づく分散",
        "B": "日付範囲に基づく分割（例えば月単位）",
        "C": "ラウンドロビンルール",
        "D": "無作為に分散"
      },
      "correct": "B",
      "explanation": "Range パーティショニングは、特定の値の範囲に基づいてデータを分割します。日付カラムをパーティショニングキーとして、月単位や年単位でデータを分割することが一般的です。"
    },
    {
      "id": "sql_advanced_027",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "クエリ内で \"N+1 問題\" が発生する最も一般的なシナリオは何か？",
      "options": {
        "A": "複数のテーブルの複雑な結合",
        "B": "1つの保持者行に対して N 個の従属行を個別クエリで取得する",
        "C": "インデックス不足",
        "D": "メモリ不足"
      },
      "correct": "B",
      "explanation": "N+1問題は、1つの親行を取得するクエリで1、その親行の各々に対して個別に子行を取得するクエリで N が発生し、合計 N+1 のクエリが実行されることです。JOINやサブクエリで解決します。"
    },
    {
      "id": "sql_advanced_028",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "JOIN最適化の観点から、\"最も制限的な条件\" はどこに配置すべきか？",
      "options": {
        "A": "最初の JOIN 句",
        "B": "最後の JOIN 句",
        "C": "WHERE 句",
        "D": "SELECT 句"
      },
      "correct": "A",
      "explanation": "最も制限的な条件（フィルターの対象行数が少ない条件）を最初に適用することで、後続の JOIN で処理する行数を削減し、クエリ全体の効率が向上します。"
    },
    {
      "id": "sql_advanced_029",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "\"クエリ述部プッシュダウン\" の最も正確な説明はどれか？",
      "options": {
        "A": "WHERE 条件をできるだけ早く適用して処理すべきデータを減らすこと",
        "B": "WHERE 条件を遅延して適用すること",
        "C": "クエリを複数に分割すること",
        "D": "インデックスを強制的に使用すること"
      },
      "correct": "A",
      "explanation": "述部プッシュダウンは、フィルター条件（WHERE 句）をクエリ実行の早い段階で適用することで、処理するデータセットを最小化し、パフォーマンスを向上させるオプティマイザの技術です。"
    },
    {
      "id": "sql_advanced_030",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "バッチ処理（Batch Processing）の主な利点は何か？",
      "options": {
        "A": "個別のクエリを実行するより効率的にデータを処理できる",
        "B": "内存使用量を増加させる",
        "C": "トランザクション数を増加させる",
        "D": "ロック期間を延長する"
      },
      "correct": "A",
      "explanation": "バッチ処理は、複数のデータ修正操作をソートしてまとめて実行することで、個別のクエリよりもディスクアクセスを効率化し、全体的なパフォーマンスを向上させます。"
    },
    {
      "id": "sql_advanced_031",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "実行計画の \"残り行数（Rows）\" が推定値と大きく異なる場合、考えられる原因は何か？",
      "options": {
        "A": "インデックスが古い",
        "B": "テーブル統計が古いまたは不正確である",
        "C": "クエリオプティマイザが壊れている",
        "D": "クエリ構文が不正"
      },
      "correct": "B",
      "explanation": "統計情報が古いまたは不正確な場合、オプティマイザは誤った推定値を算出し、不適切な実行計画を選択する可能性があります。ANALYZE コマンドで統計を更新する必要があります。"
    },
    {
      "id": "sql_advanced_032",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "基礎",
      "question": "カバリングインデックス（Covering Index）の主な利点は何か？",
      "options": {
        "A": "テーブルをアクセスしなくても、インデックスだけで検索できる",
        "B": "インデックスのサイズを減らすことができる",
        "C": "自動的にデータをバックアップする",
        "D": "ロック競合を解決する"
      },
      "correct": "A",
      "explanation": "カバリングインデックスは、WHERE 句で使用される列と結果セットに含まれるすべての列を含むインデックスです。テーブル全体をアクセスせずにインデックスだけで結果を返せるため、\"Index Only Scan\" が可能になり、パフォーマンスが大幅に向上します。"
    },
    {
      "id": "sql_advanced_033",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "フルテキストサーチ（Full-Text Search）インデックスの著な利点は何か？",
      "options": {
        "A": "LIKE \"％text％\" より高速に全文検索ができる",
        "B": "ディスク容量を節約する",
        "C": "データベースのセキュリティを強化する",
        "D": "ロック競合を完全に排除する"
      },
      "correct": "A",
      "explanation": "フルテキストサーチインデックスは、テキストデータを単語単位でインデックス化し、LIKE 句より効率的に与えられたテキストを検索できます。"
    },
    {
      "id": "sql_advanced_034",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "部分インデックス（Partial Index）の主な用途はどれか？",
      "options": {
        "A": "非アクティブなレコードをフィルタリングして、インデックスサイズを削減する",
        "B": "すべてのレコードをインデックスに含める",
        "C": "自動的にデータをバックアップする",
        "D": "ネットワーク帯域幅を改善する"
      },
      "correct": "A",
      "explanation": "部分インデックスは WHERE 条件で特定の行のみをインデックス化します。例えば、is_active = true の行のみをインデックスすることで、インデックスサイズを削減し、パフォーマンスを向上させるできます。"
    },
    {
      "id": "sql_advanced_035",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "クエリ内の UNION と UNION ALL の性能上の違いは何か？",
      "options": {
        "A": "UNION は重複排除により処理負荷が高く、UNION ALL は高速",
        "B": "UNION ALL は重複排除により処理負荷が高い",
        "C": "機能的に違いはない",
        "D": "UNION は並列処理可能だが、UNION ALL は不可"
      },
      "correct": "A",
      "explanation": "UNION は重複行を排除するため、追加の処理が必要です。UNION ALL は全行を返すため、より高速です。重複排除が必要ない場合は UNION ALL を使用するべきです。"
    },
    {
      "id": "sql_advanced_036",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "NOT IN vs NOT EXISTS の性能の違いについて、最も正確な説明はどれか？",
      "options": {
        "A": "機能的に違いはなく、常に同じパフォーマンスである",
        "B": "NOT EXISTS は通常、NOT IN より高速。NOT IN は NULL 値を含むサブクエリの場合、問題が生じる可能性がある",
        "C": "NOT IN は常に NOT EXISTS より高速",
        "D": "パフォーマンスはデータベースエンジンに依存"
      },
      "correct": "B",
      "explanation": "NOT EXISTS は通常、NOT IN より高速です。また、NOT IN はサブクエリに NULL 値が含まれる場合、予期しない結果を返す可能性があります。"
    },
    {
      "id": "sql_advanced_037",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "クエリ内で GROUP BY のすべてのカラムをインデックス化する必要があるか？",
      "options": {
        "A": "必須である",
        "B": "推奨されるが、必須ではない。最初の列のインデックスだけでも大幅な効率向上が期待される",
        "C": "不要である",
        "D": "データベースエンジンの種類に依存する"
      },
      "correct": "B",
      "explanation": "GROUP BY のすべてのカラムをインデックス化する必要はありませんが、最初のカラムをインデックス化することで、グループ化が効率化される可能性があります。"
    },
    {
      "id": "sql_advanced_038",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "スローログ（Slow Log）の主な目的は何か？",
      "options": {
        "A": "クローズアップしたサンプルの記録",
        "B": "指定された実行時間（例えば1秒）を超えるクエリを記録してボトルネック特定を支援する",
        "C": "ユーザーのログイン情報を記録する",
        "D": "ディスク容量の使用履歴を記録する"
      },
      "correct": "B",
      "explanation": "スローログに記録されるクエリは、パフォーマンス問題の原因となる可能性が高いヒントを提供します。これらのクエリを特定・最適化することで、全体的なデータベースパフォーマンスを向上させられます。"
    },
    {
      "id": "sql_advanced_039",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "NULL 値が多く含まれるカラムにインデックスを作成する場合の注意点は何か？",
      "options": {
        "A": "NULL 値はインデックスに含まれないため、NULL チェッククエリではインデックスが使用されない可能性がある",
        "B": "NULL 値がインデックスサイズを大幅に増加させる",
        "C": "NULL 値はパフォーマンスに影響しない",
        "D": "NULL 値を含むカラムはインデックス化できない"
      },
      "correct": "A",
      "explanation": "多くのデータベースシステムではインデックスに NULL 値を含まないため、\"column IS NULL\" のようなクエリではインデックスが使用されない可能性があります。"
    },
    {
      "id": "sql_advanced_040",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "複合インデックスで列の順序を決める際の一般的なルールは何か？",
      "options": {
        "A": "WHERE 句の列の順序と同じにする",
        "B": "カラム名のアルファベット順",
        "C": "選択度が高いものから低いものへ（基数的ソート）",
        "D": "ランダムな順序"
      },
      "correct": "C",
      "explanation": "複合インデックスでは、選択度（distinctness）が高い列（値の種類が多い列）から低い列へ順序付けることで、インデックスの効率が向上します。ただし、WHERE 句での使用パターンも考慮する必要があります。"
    },
    {
      "id": "sql_advanced_041",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "基礎",
      "question": "自動インクリメント型（AUTO_INCREMENT）のカラムがプライマリキーとして使用される理由は何か？",
      "options": {
        "A": "ビジネスロジックに意味がある",
        "B": "開発が簡単で、ディスク効率も良く、挿入パフォーマンスが向上する",
        "C": "セキュリティを強化する",
        "D": "ロック競合を完全に排除する"
      },
      "correct": "B",
      "explanation": "自動インクリメント型のプライマリキーは、ディスク効率が良く、インデックスのサイズを最小化できます。また、連続的に増加するため、ディスク上に順序付けされたデータを格納できます。"
    },
    {
      "id": "sql_advanced_042",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "クエリ結果をキャッシュする際、不変性（Immutability）が重要とされる理由は何か？",
      "options": {
        "A": "キャッシュが不変なら、同じクエリの結果は常に同じだと保証される",
        "B": "メモリ使用量を削減する",
        "C": "ディスク容量を節約する",
        "D": "ネットワーク帯域幅を改善する"
      },
      "correct": "A",
      "explanation": "キャッシュされたデータが不変なら、キャッシュをずっと安全に再利用できます。キャッシュ無効化のタイミングを決める必要がなく、パフォーマンスが向上します。"
    },
    {
      "id": "sql_advanced_043",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "関数ベースインデックス（Function-based Index/Generated Index）の使用例はどれか？",
      "options": {
        "A": "UPPER(email) でメールアドレスを大文字で検索する場合",
        "B": "テーブルの単純なカラムインデックス",
        "C": "ハッシュインデックス",
        "D": "部分インデックス"
      },
      "correct": "A",
      "explanation": "関数ベースインデックスは、カラムに関数を適用した結果に対するインデックスです。例えば、UPPER(email) でインデックスを作成すると、\"WHERE UPPER(email) = 'JOHN@EXAMPLE.COM'\" クエリがインデックスを使用できます。"
    },
    {
      "id": "sql_advanced_044",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "中級",
      "question": "\"クエリプラン キャッシュ\" の主な目的は何か？",
      "options": {
        "A": "実行計画を保存して、同じクエリの再実行時に再計算を避ける",
        "B": "クエリ結果を貯蔵する",
        "C": "インデックスを自動的に作成する",
        "D": "ログファイルを圧縮する"
      },
      "correct": "A",
      "explanation": "クエリプランキャッシュは、コンパイル済みの実行計画を保存することで、パラメータ化されたクエリの同じ構造の再実行時に、オプティマイザの再実行を避けてパフォーマンスを向上させます。"
    },
    {
      "id": "sql_advanced_045",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "応用",
      "question": "\"スキャン キー\" と \"フィルター述部\" の最も正確な説明はどれか？",
      "options": {
        "A": "スキャン キーはインデックスで行を絞り込み、フィルター述部はテーブルスキャン後に行をフィルタリング",
        "B": "機能的に違いはない",
        "C": "フィルター述部がスキャン キーより優先される",
        "D": "スキャン キーはテーブルスキャン後に適用される"
      },
      "correct": "A",
      "explanation": "スキャン キーはインデックス検索フェーズで適用され、最初に行うセットを絞り込みます。フィルター述部は、絞り込まれた行に対して追加の条件を適用し、最終的な結果を特定します。"
    },
    {
      "id": "sql_advanced_046",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "応用",
      "question": "ネストされたループジョイン（Nested Loop Join）がテーブルTABLE1（100行）とTABLE2（10000行）の結合に使用される場合、最大の比較操作数はいくつか？",
      "options": {
        "A": "100",
        "B": "10100",
        "C": "1000000",
        "D": "100 x 10000 = 1000000"
      },
      "correct": "D",
      "explanation": "ネストループジョインは、外側のテーブルの各行に対して内側のテーブルをスキャンするため、最大の比較操作数は外側テーブルの行数 × 内側テーブルの行数になります。"
    },
    {
      "id": "sql_advanced_047",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "応用",
      "question": "ハッシュジョイン（Hash Join）がより効率的なシナリオはどれか？",
      "options": {
        "A": "小さなテーブル × 大きなテーブルでジョイン条件にインデックスがない場合",
        "B": "ネストループジョインが常に最適",
        "C": "等号条件を持つジョインでニーズは関係ない",
        "D": "ソート操作が不要"
      },
      "correct": "A",
      "explanation": "ハッシュジョインは、小さなテーブルを用いてハッシュテーブルを構築し、大きなテーブルをプローブするため、小さなテーブル × 大きなテーブルの等号条件ジョインで効率的です。"
    },
    {
      "id": "sql_advanced_048",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "応用",
      "question": "マージジョイン（Merge Join）の前提条件として必須のものはどれか？",
      "options": {
        "A": "両テーブルがジョイン列でソートされていること",
        "B": "両テーブルに同じサイズであること",
        "C": "インデックスが存在すること",
        "D": "ハッシュテーブルが必要"
      },
      "correct": "A",
      "explanation": "マージジョインは、両テーブルがジョイン列でソートされていることを前提としています。あらかじめソートでるいない場合、コストが高くなります。"
    },
    {
      "id": "sql_advanced_049",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "応用",
      "question": "パラメータ化クエリ（Parameterized Query）の最も重要なメリットは何か？",
      "options": {
        "A": "実行速度が向上する",
        "B": "SQL インジェクション攻撃を防ぎ、クエリプランキャッシュを活用できる",
        "C": "ディスク容量を回収する",
        "D": "メモリ使用量を削減する"
      },
      "correct": "B",
      "explanation": "パラメータ化クエリはリテラル値をパラメータに置き換えることで、SQL インジェクションを防ぎ、同じクエリ構造の複数実行時にクエリプランがキャッシュされてパフォーマンスが向上します。"
    },
    {
      "id": "sql_advanced_050",
      "genre": "高度なSQL・最適化",
      "exam": "SQL",
      "level": "応用",
      "question": "実際のMB単位のディスク容量を削減するために、最も効果的なアプローチはどれか？",
      "options": {
        "A": "外部テーブル（External Table）の使用",
        "B": "テーブル圧縮（Compression）とパーティショニングの組み合わせ",
        "C": "インデックスの削除",
        "D": "クエリキャッシュの有効化"
      },
      "correct": "B",
      "explanation": "テーブル圧縮はディスク容量を削減し、パーティショニングは古いパーティションをアーカイブできます。この組み合わせにより、ディスク使用量を最小化できます。"
    }
  ]
}