{
  "genre": "オブジェクト指向",
  "exam": "Java",
  "category": "java_oop",
  "questions": [
    {
      "id": "java_oop_001",
      "question": "オブジェクト指向プログラミングの 4 つの主要原則として正しいものはどれか。",
      "choices": [
        "カプセル化、継承、ポリモーフィズム、抽象化",
        "カプセル化、継承、ポリモーフィズム、最適化",
        "カプセル化、拡張、ポリモーフィズム、抽象化",
        "封装、継承、多様性、統計化"
      ],
      "answer": 0,
      "explanation": "OOP の 4 つの原則は『カプセル化』『継承』『ポリモーフィズム』『抽象化』です。"
    },
    {
      "id": "java_oop_002",
      "question": "クラスとオブジェクトの関係について、正しい説明はどれか。",
      "choices": [
        "クラスはオブジェクトのテンプレートであり、オブジェクトはクラスのインスタンスである",
        "オブジェクトはクラスのテンプレートである",
        "クラスとオブジェクトは同一の概念",
        "オブジェクトからクラスを生成する"
      ],
      "answer": 0,
      "explanation": "クラスは設計図、オブジェクトは実際のインスタンスです。クラス定義に基づき、複数のオブジェクト（インスタンス）を生成できます。"
    },
    {
      "id": "java_oop_003",
      "question": "継承について、正しい説明はどれか。",
      "choices": [
        "Java は多重継承をサポートしている",
        "Java は単一継承のみ対応であり、クラス間の継承は 1 つの親クラスから のみできる",
        "継承は常にパフォーマンスを向上させる",
        "継承を使用しないコードはオブジェクト指向ではない"
      ],
      "answer": 1,
      "explanation": "Java は単一継承のみです。多重継承は interface を使用して実現します。"
    },
    {
      "id": "java_oop_004",
      "question": "ポリモーフィズムについて、正しい説明はどれか。",
      "choices": [
        "ポリモーフィズムは『多形』で、同じメソッド名で異なる動作を実現する",
        "ポリモーフィズムはコンパイル時にのみ解決される",
        "ポリモーフィズムは継承と併用できない",
        "ポリモーフィズムは低パフォーマンスのため避けるべき"
      ],
      "answer": 0,
      "explanation": "ポリモーフィズムはメソッドオーバーロード（コンパイル時）とメソッドオーバーライド（実行時）で実現されます。"
    },
    {
      "id": "java_oop_005",
      "question": "メソッドオーバーロードについて、正しい説明はどれか。",
      "choices": [
        "同じメソッド名で異なるシグネチャ（パラメータ型・数）を持つ複数メソッドが定義可能",
        "メソッドオーバーロードはメソッド名が異なる必要がある",
        "メソッドオーバーロードは戻り値の型のみ異なってもよい",
        "メソッドオーバーロードは実行時に動的に解決される"
      ],
      "answer": 0,
      "explanation": "オーバーロードはシグネチャ（パラメータ型や数）が異なる場合に同じメソッド名が使用可能です。戻り値のみ異ならはオーバーロードではありません。"
    },
    {
      "id": "java_oop_006",
      "question": "メソッドオーバーライドについて、正しい説明はどれか。",
      "choices": [
        "メソッドオーバーライドは親クラスと同じシグネチャを持つメソッドを子クラスで再実装する",
        "メソッドオーバーライドはメソッド名のみ同じであればよい",
        "メソッドオーバーライドはコンパイル時に型チェックされない",
        "メソッドオーバーライドは @Overriding アノテーションが必須"
      ],
      "answer": 0,
      "explanation": "オーバーライドは親クラスのメソッドと完全に同じシグネチャを子クラスで再実装します。@Override アノテーションはオプションですが推奨です。"
    },
    {
      "id": "java_oop_007",
      "question": "カプセル化について、正しい説明はどれか。",
      "choices": [
        "データメンバを private に隠蔽し、public メソッドでアクセスを制御する",
        "カプセル化はすべてのデータを public にすることを意味する",
        "カプセル化によりプログラムの実行速度が向上する",
        "カプセル化なしでオブジェクト指向は実現できない"
      ],
      "answer": 0,
      "explanation": "カプセル化は内部状態を隠蔽し、インターフェース経由でのアクセスに制限することで、保守性と堅牢性を向上させます。"
    },
    {
      "id": "java_oop_008",
      "question": "抽象クラス（abstract class）と interface の違いとして正しいものはどれか。",
      "choices": [
        "抽象クラスはメンバ変数を持つことができ、interface は定数のみ",
        "抽象クラスは単一継承のみで、interface は複数実装可能",
        "抽象クラスはコンストラクタを持つことができ、interface は持たない",
        "すべて正しい"
      ],
      "answer": 3,
      "explanation": "すべての説明が正しいです。抽象クラスはクラスであり、interface は契約を定義するメカニズムです。"
    },
    {
      "id": "java_oop_009",
      "question": "以下のコードの出力は何か？\nclass Animal {\n  public void sound() { System.out.println(\"generic\"); }\n}\nclass Dog extends Animal {\n  public void sound() { System.out.println(\"woof\"); }\n}\nAnimal a = new Dog();\na.sound();",
      "choices": [
        "generic",
        "woof",
        "コンパイルエラー",
        "実行時エラー"
      ],
      "answer": 1,
      "explanation": "参照型は Animal ですが、実際のオブジェクトは Dog インスタンスです。実行時に Dog クラスのメソッドが呼び出される（動的ディスパッチ）ため『woof』が出力されます。"
    },
    {
      "id": "java_oop_010",
      "question": "abstract メソッドについて、正しい説明はどれか。",
      "choices": [
        "abstract メソッドを含むクラスは必ず abstract クラスである",
        "abstract メソッドはメソッド本体を持つことができる",
        "abstract クラスはすべてのメソッドが abstract である必要がある",
        "abstract メソッドはクラスの外でも定義可能"
      ],
      "answer": 0,
      "explanation": "abstract メソッドを含むクラスは必ず abstract クラスである必要があります。同時に concrete メソッドも持つことができます。"
    }
  ]
}
