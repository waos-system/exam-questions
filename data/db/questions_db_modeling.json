{
  "genre": "データベーススペシャリスト",
  "exam": "データベーススペシャリスト試験",
  "category": "db_modeling",
  "questions": [
    {
      "id": "db_modeling_001",
      "question": "第1正規形（1NF）の条件として最も適切なものはどれか。",
      "choices": [
        "すべての属性の値が単一である",
        "主キーがある",
        "推移的関数従属がない",
        "複合主キーがある"
      ],
      "answer": 0,
      "explanation": "1NFの条件は、すべての属性値が単一値（原子値）であり、繰り返しグループがないこと。複数値を持つ属性を排除する。"
    },
    {
      "id": "db_modeling_002",
      "question": "第2正規形（2NF）の条件として最も適切なものはどれか。",
      "choices": [
        "推移的関数従属がない",
        "すべての非キー属性が主キー全体に完全関数従属",
        "部分関数従属を持つ",
        "候補キーが複数ある"
      ],
      "answer": 1,
      "explanation": "2NFは1NFであって、かつすべての非キー属性が主キー全体に完全関数従属している状態。部分関数従属を排除。"
    },
    {
      "id": "db_modeling_003",
      "question": "第3正規形（3NF）の条件として最も適切なものはどれか。",
      "choices": [
        "推移的関数従属がない",
        "複合主キーがない",
        "すべての属性が原子値",
        "関数従属がない"
      ],
      "answer": 0,
      "explanation": "3NFは2NFであって、かつ非キー属性間の推移的関数従属がない状態。非キー属性間の依存性を排除。"
    },
    {
      "id": "db_modeling_004",
      "question": "正規化のメリットとして最も適切なものはどれか。",
      "choices": [
        "クエリ速度の向上",
        "データ冗長性排除による更新異常の防止",
        "ディスク容量削減",
        "複数テーブル結合の完全回避"
      ],
      "answer": 1,
      "explanation": "正規化により、データ冗長性が排除され、新規挿入異常・削除異常・更新異常を防ぎ、データ整合性を確保できる。"
    },
    {
      "id": "db_modeling_005",
      "question": "非正規化（反正規化）を適用する場合として最も適切なものはどれか。",
      "choices": [
        "すべてのシステムに推奨される",
        "読取性能重視でデータ冗長性を容認できる場合",
        "更新頻度が高い場合",
        "複雑な結合を避ける場合のみ"
      ],
      "answer": 1,
      "explanation": "非正規化は、読取性能向上が必要で、データ冗長性による更新複雑性を許容できるOLAP型システムに適用。"
    },
    {
      "id": "db_modeling_006",
      "question": "ER図（実体関係図）において、1対多の関係を表現する方法として最も適切なものはどれか。",
      "choices": [
        "カラム数増加",
        "親テーブルができる",
        "子テーブルに親テーブルのPKを外部キーとして持たせる",
        "両テーブルに相互参照キーを持たせる"
      ],
      "answer": 2,
      "explanation": "1対多の関係は、子テーブル側に親テーブルの主キーを外部キー（FK）として持たせることで実装される。"
    },
    {
      "id": "db_modeling_007",
      "question": "多対多の関係をリレーショナルモデルで実装する方法として最も適切なものはどれか。",
      "choices": [
        "1つのテーブルで両エンティティを統合",
        "結合テーブルを作成し、各親テーブルのPKを外部キーとして持たせる",
        "一方のテーブルに配列カラムを追加",
        "複雑な結合クエリで処理"
      ],
      "answer": 1,
      "explanation": "多対多の関係は、結合テーブル（中間テーブル）を作成し、両側の親テーブルのPKを外部キーとして持たせることで実装。"
    },
    {
      "id": "db_modeling_008",
      "question": "主キー（Primary Key）の選定基準として最も重要なものはどれか。",
      "choices": [
        "最小カラム数である",
        "一意性を持ち、NULL値がなく、値変更が少ないこと",
        "数値型である",
        "最初のカラムである"
      ],
      "answer": 1,
      "explanation": "主キーは、一意性確保・NULL不許可・値の安定性（変更が少ない）を満たす必要。これが参照整合性を支える基本。"
    },
    {
      "id": "db_modeling_009",
      "question": "代理キー（Surrogate Key）を使用する理由として最も適切なものはどれか。",
      "choices": [
        "ビジネスキーよりシンプルで変更に強い",
        "ディスク容量削減",
        "すべてのテーブルに必須",
        "複合キーの完全な回避"
      ],
      "answer": 0,
      "explanation": "代理キー（例：自動採番ID）はビジネスキーより変更に強く、シンプルで参照整合性管理が容易。ただしビジネスキーも必要。"
    },
    {
      "id": "db_modeling_010",
      "question": "外部キー（Foreign Key）制約の主な目的として最も適切なものはどれか。",
      "choices": [
        "クエリ速度向上",
        "参照整合性確保、孤立レコード防止",
        "ディスク容量削減",
        "テーブル結合の完全回避"
      ],
      "answer": 1,
      "explanation": "外部キー制約により、親レコードなしの子レコード作成を防ぎ、削除時の孤立レコードを防ぎ、データ整合性を確保。"
    },
    {
      "id": "db_modeling_011",
      "question": "テーブル設計でスーパータイプ・サブタイプ関係を実装する方法として最も効率的なものはどれか。",
      "choices": [
        "別々のテーブルで完全に分離",
        "1つのテーブルで統合",
        "スーパー+各サブタイプを別テーブル化",
        "属性ごとにテーブル分割"
      ],
      "answer": 2,
      "explanation": "スーパータイプ・サブタイプは、スーパータイプに共通属性、サブタイプに固有属性を配置し、外部キーで結合。"
    },
    {
      "id": "db_modeling_012",
      "question": "ファクトテーブルとディメンションテーブルの役割として最も適切なものはどれか。",
      "choices": [
        "ファクト：マスタ",
        "ファクト：計測値、ディメンション：分析軸",
        "関連性なし",
        "ファクトのみで十分"
      ],
      "answer": 1,
      "explanation": "スターモデル：ファクトテーブルが定量情報（売上等）、ディメンションテーブルが分析軸（時間・地域・顧客等）を保持。"
    },
    {
      "id": "db_modeling_013",
      "question": "スノーフレークモデルの特徴として最も適切なものはどれか。",
      "choices": [
        "ファクト複数",
        "ディメンションが正規化されている",
        "クエリ簡単",
        "全体的に高速"
      ],
      "answer": 1,
      "explanation": "スノーフレーク：スターのディメンションをさらに正規化。容量削減だが複雑性増加。"
    },
    {
      "id": "db_modeling_014",
      "question": "シャーディング（Sharding）の主な目的として最も適切なものはどれか。",
      "choices": [
        "全集約",
        "大規模データを複数サーバに分散、スケーラビリティ確保",
        "バックアップ",
        "複雑なJOIN最適化"
      ],
      "answer": 1,
      "explanation": "シャーディング：大規模テーブルを複数の物理テーブルに水平分割。スケーラビリティと性能を実現。"
    },
    {
      "id": "db_modeling_015",
      "question": "インデックス戦略として最も効果的な対象として最も適切なものはどれか。",
      "choices": [
        "全カラム",
        "WHERE・JOIN・ORDER BY条件で頻繁に使用されるカラム",
        "TEXT型のみ",
        "主キーのみ"
      ],
      "answer": 1,
      "explanation": "インデックスは、検索条件・結合条件・ソート対象となるカラムに設定し、ランダムアクセス性能を向上。"
    },
    {
      "id": "db_modeling_016",
      "question": "複合インデックスの効果的なカラム順序として最も適切なものはどれか。",
      "choices": [
        "任意",
        "等値条件カラム→範囲条件カラム",
        "辞書順",
        "頻度低い順"
      ],
      "answer": 1,
      "explanation": "複合インデックス：等値条件を先頭に、範囲条件を後に配置することで、インデックス利用効率が最大化。"
    },
    {
      "id": "db_modeling_017",
      "question": "時系列データを日次パーティションに分割する主なメリットとして最も適切なものはどれか。",
      "choices": [
        "複雑化",
        "古いデータ効率的削除、新規データ高速挿入",
        "容量増加",
        "結合削減"
      ],
      "answer": 1,
      "explanation": "時系列パーティション：古いパーティション一括削除、新規パーティション高速挿入。管理性向上。"
    },
    {
      "id": "db_modeling_018",
      "question": "テーブルの履歴管理を実装する方法として最も適切なものはどれか。",
      "choices": [
        "上書き",
        "履歴テーブルに有効開始・終了日時保持、時間軸管理",
        "複数DB",
        "不要"
      ],
      "answer": 1,
      "explanation": "履歴管理：履歴テーブルに有効開始日時・終了日時設定し、時点でのデータ状態を復元可能。"
    },
    {
      "id": "db_modeling_019",
      "question": "デノーマライズ適用時に注意すべき点として最も適切なものはどれか。",
      "choices": [
        "更新複雑性増加理解",
        "全て統合",
        "併用不要",
        "スキーマ固定"
      ],
      "answer": 0,
      "explanation": "デノーマライズ：読取性能向上の代わりに、更新複雑性増加と冗長性管理の負担が増加。トレードオフ理解が必須。"
    },
    {
      "id": "db_modeling_020",
      "question": "新しい属性が頻繁に追加される場合の最も柔軟な方法はどれか。",
      "choices": [
        "カラム追加",
        "EAV（Entity-Attribute-Value）モデル",
        "不要",
        "スキーマ完全構築"
      ],
      "answer": 1,
      "explanation": "EAVモデル：属性を動的に追加可能。スキーマ変更不要で拡張性高い。性能トレードオフあり。"
    },
    {
      "id": "db_modeling_021",
      "question": "ビット演算フラグ管理と通常カラム管理のトレードオフとして最も適切なものはどれか。",
      "choices": [
        "容量削減vs可読性",
        "可読性のみ",
        "性能のみ",
        "差異なし"
      ],
      "answer": 0,
      "explanation": "ビット：容量削減・性能向上だが可読性低い。通常カラム：容量多いが可読性高い。通常カラム推奨。"
    },
    {
      "id": "db_modeling_022",
      "question": "NoSQLドキュメント型を選択する理由として最も適切なものはどれか。",
      "choices": [
        "スキーマ固定",
        "スキーマレス、ネスト構造、柔軟な進化",
        "ACID保証強靭",
        "複雑JOIN"
      ],
      "answer": 1,
      "explanation": "ドキュメント型NoSQL：スキーマレス・ネスト構造・柔軟進化。複雑JOIN・ACID保証は弱点。"
    },
    {
      "id": "db_modeling_023",
      "question": "チェック制約（CHECK制約）の主な目的として最も適切なものはどれか。",
      "choices": [
        "外部キー",
        "カラム値の有効範囲・フォーマット制限",
        "ユニーク制約",
        "NULL制御"
      ],
      "answer": 1,
      "explanation": "CHECK制約：カラム値が条件式を満たすことを保証。例：年齢>=0。データ品質向上。"
    },
    {
      "id": "db_modeling_024",
      "question": "単一テーブル継承（Single Table Inheritance）の特徴として最も適切なものはどれか。",
      "choices": [
        "複数テーブル",
        "1テーブルに全データ、タイプカラムで区別",
        "複雑結合",
        "NULL少なし"
      ],
      "answer": 1,
      "explanation": "単一テーブル継承：全サブタイプを1テーブルに保持。シンプルだが、NULL多発リスク。"
    },
    {
      "id": "db_modeling_025",
      "question": "クラステーブル継承の特徴として最も適切なものはどれか。",
      "choices": [
        "1テーブル",
        "親+各サブタイプを別テーブル、結合で再構成",
        "結合不要",
        "NULL多数"
      ],
      "answer": 1,
      "explanation": "クラステーブル継承：スーパー・各サブタイプを別テーブル。正規化レベル高いが、結合コスト増。"
    },
    {
      "id": "db_modeling_026",
      "question": "JSON型カラムをサポートするRDBのメリットとして最も適切なものはどれか。",
      "choices": [
        "完全スキーマレス",
        "構造化+セミ構造データ混在、柔軟性確保",
        "性能向上",
        "ACID廃止"
      ],
      "answer": 1,
      "explanation": "JSON型：RDBの強力性とNoSLの柔軟性を兼備。JSON関数でクエリも可能。ハイブリッド。"
    },
    {
      "id": "db_modeling_027",
      "question": "テンポラルテーブル（Temporal Table）の主な利点として最も適切なものはどれか。",
      "choices": [
        "過去削除",
        "時間軸でのデータ変更追跡、時点復元",
        "容量削減",
        "低速化"
      ],
      "answer": 1,
      "explanation": "Temporal Table：有効期間を自動管理し、過去のいずれかの時点でのデータ状態を復元可能。監査対応。"
    },
    {
      "id": "db_modeling_028",
      "question": "レンジシャーディング（Range Sharding）の特徴として最も適切なものはどれか。",
      "choices": [
        "均等",
        "キー値範囲で分割、シンプルだがデータ偏在可能性",
        "ハッシュ",
        "全収集"
      ],
      "answer": 1,
      "explanation": "レンジシャーディング：キー範囲で分割（例：日付）。シンプルだが、キー分布非均等でデータ偏在。"
    },
    {
      "id": "db_modeling_029",
      "question": "ハッシュシャーディング（Hash Sharding）の利点として最も適切なものはどれか。",
      "choices": [
        "範囲参照容易",
        "ハッシュで均等分散、ホットスポット回避",
        "範囲クエリ高速",
        "複雑性低い"
      ],
      "answer": 1,
      "explanation": "ハッシュシャーディング：ハッシュ値で均等分散、データ偏在回避。範囲クエリは全シャード走査必要。"
    },
    {
      "id": "db_modeling_030",
      "question": "グローバルセカンダリインデックス（Global Secondary Index）の役割として最も適切なものはどれか。",
      "choices": [
        "プライマリキーのみ",
        "主キー以外でのクエリ最適化",
        "複製不要",
        "トランザクション保証"
      ],
      "answer": 1,
      "explanation": "GSI：プライマリキー以外のカラムでの検索効率化。複製コスト・レイテンシのトレードオフ。"
    },
    {
      "id": "db_modeling_031",
      "question": "マイクロサービスでのDB選定戦略として最も推奨されるものはどれか。",
      "choices": [
        "全サービス共用DB",
        "サービスごとに専用DB、API経由でアクセス",
        "RDB限定",
        "DB不要"
      ],
      "answer": 1,
      "explanation": "マイクロサービス：各サービスの独立性・スケーラビリティのため、専用DB配置。サービス間はAPI連携。"
    },
    {
      "id": "db_modeling_032",
      "question": "イベントソーシング（Event Sourcing）パターンのデータ永続化方式として最も適切なものはどれか。",
      "choices": [
        "現在状態のみ",
        "すべての状態変更イベントをログ記録、現在状態は再計算",
        "削除操作許可",
        "履歴不要"
      ],
      "answer": 1,
      "explanation": "Event Sourcing：状態変化をイベント記録。時間軸での再現・監査追跡可能。CQRS併用が一般的。"
    },
    {
      "id": "db_modeling_033",
      "question": "CQRS（Command Query Responsibility Segregation）パターンの設計構造として最も適切なものはどれか。",
      "choices": [
        "同一モデル",
        "書込コマンド・読取クエリを分離、異なるモデルで最適化",
        "クエリのみ分離",
        "変更不要"
      ],
      "answer": 1,
      "explanation": "CQRS：書込・読取を分離し、各々を異なるモデルで最適化。Event Sourcingと組合わせ効果的。"
    },
    {
      "id": "db_modeling_034",
      "question": "リード・レプリカ（Read Replica）構成での運用方法として最も適切なものはどれか。",
      "choices": [
        "全クエリをレプリカ",
        "読取をレプリカ分散、書込はプライマリに集約",
        "プライマリのみ",
        "不要"
      ],
      "answer": 1,
      "explanation": "リード・レプリカ：読取を複数レプリカに分散。書込はプライマリに集約し、一貫性確保。"
    },
    {
      "id": "db_modeling_035",
      "question": "キャッシュ層（Redis等）導入の基準として最も適切なものはどれか。",
      "choices": [
        "全クエリキャッシュ",
        "頻繁アクセス・読取多い・変更少ないデータ",
        "変更頻繁",
        "不要"
      ],
      "answer": 1,
      "explanation": "キャッシュ：読取頻度高い・変更少ないデータに有効。無効化戦略と一貫性確保が課題。"
    },
    {
      "id": "db_modeling_036",
      "question": "スキーマエボリューション（Schema Evolution）で既存システムのダウンタイムなく新カラム追加する方法として最も適切なものはどれか。",
      "choices": [
        "全再構築",
        "新カラムをNULL許可で追加、段階的データ移行",
        "旧アプリ廃止",
        "不可"
      ],
      "answer": 1,
      "explanation": "スキーマエボリューション：新カラムをNULL許可で追加、バックグラウンドでデータ移行。ダウンタイムゼロ。"
    },
    {
      "id": "db_modeling_037",
      "question": "データウェアハウス設計でファクト（集計）を段階的に集計する方法として最も適切なものはどれか。",
      "choices": [
        "毎回全集計",
        "粒度別（日→月→年）に段階集計テーブル作成",
        "集計不要",
        "手動集計"
      ],
      "answer": 1,
      "explanation": "段階集計：低粒度から高粒度への効率化。日別集計から月別を作成（高速化）。"
    },
    {
      "id": "db_modeling_038",
      "question": "リアルタイムデータウェアハウスでの課題として最も適切なものはどれか。",
      "choices": [
        "集計不要",
        "ETL遅延、データ一貫性、高スループット処理",
        "ベース不要",
        "ツール不要"
      ],
      "answer": 1,
      "explanation": "リアルタイムDW：ストリーミングデータ高速ETL、トランザクション系との一貫性が課題。"
    },
    {
      "id": "db_modeling_039",
      "question": "ガバナンス・マスターデータ管理（MDM）観点でのデータ品質ルールとして最も適切なものはどれか。",
      "choices": [
        "ルール不要",
        "一意性、参照整合性、妥当性、完全性（NULL）",
        "参照整合性のみ",
        "柔軟性優先"
      ],
      "answer": 1,
      "explanation": "MDM：一意性・参照整合性・妥当性・完全性をルール化。マスターデータの信頼性・再利用性確保。"
    },
    {
      "id": "db_modeling_040",
      "question": "機密情報を含むテーブルでアクセス制御と暗号化を組み合わせる理由として最も適切なものはどれか。",
      "choices": [
        "片方で十分",
        "アクセス制御で不正アクセス防止、暗号化で盗聴・漏洩対応。多層防御",
        "制御のみ",
        "暗号化のみ"
      ],
      "answer": 1,
      "explanation": "機密データ：ロールベースアクセス制御+暗号化（TDE・フィールドレベル）で多層防御。"
    },
    {
      "id": "db_modeling_041",
      "question": "水平分割（Horizontal Partitioning）と垂直分割（Vertical Partitioning）の違いとして最も適切なものはどれか。",
      "choices": [
        "同じ効果",
        "水平：行で分割、垂直：カラムで分割",
        "性能同じ",
        "別概念"
      ],
      "answer": 1,
      "explanation": "水平分割：行単位（パーティショニング）。垂直分割：カラム単位。異なる分割方針。"
    },
    {
      "id": "db_modeling_042",
      "question": "数値計算精度が重要なシステムでの数値カラムデータ型として最も適切なものはどれか。",
      "choices": [
        "FLOAT",
        "DECIMAL/NUMERIC - 固定小数点",
        "INT",
        "TEXT"
      ],
      "answer": 1,
      "explanation": "金融・会計系：DECIMAL/NUMERICで固定小数点。丸め誤差を回避。FLOATは浮動小数点で誤差リスク。"
    },
    {
      "id": "db_modeling_043",
      "question": "大量のテキスト検索を効率的に行うデータ型として最も適切なものはどれか。",
      "choices": [
        "VARCHAR",
        "FULLTEXT INDEX対応型またはTEXT型",
        "BLOB",
        "JSON"
      ],
      "answer": 1,
      "explanation": "全文検索：FULLTEXT INDEX対応。テキスト型カラムにインデックス設定で高速検索。"
    },
    {
      "id": "db_modeling_044",
      "question": "NULL値を適切に扱うテーブル設計の原則として最も適切なものはどれか。",
      "choices": [
        "NULL許可推奨",
        "NULL値の意味を明確に。必要最小限にNULL許可",
        "全て許可",
        "全て禁止"
      ],
      "answer": 1,
      "explanation": "NULL設計：NULL値の意味を定義。不明な値か、適用外か。外キー等では禁止。"
    },
    {
      "id": "db_modeling_045",
      "question": "タイムスタンプカラム（created_at、updated_at）を導入する利点として最も適切なものはどれか。",
      "choices": [
        "不要",
        "データ操作履歴追跡、変更検出、監査対応",
        "性能低下",
        "複雑化のみ"
      ],
      "answer": 1,
      "explanation": "タイムスタンプ：データ作成・更新時刻を自動記録。履歴追跡、変更検出、監査対応に有用。"
    },
    {
      "id": "db_modeling_046",
      "question": "ソフトデリート（論理削除）とハードデリート（物理削除）の使い分けの観点として最も適切なものはどれか。",
      "choices": [
        "同じ効果",
        "ソフト：履歴保持・復旧容易、ハード：容量削減",
        "性能同じ",
        "切り替え不要"
      ],
      "answer": 1,
      "explanation": "ソフトデリート：削除フラグで論理削除。復旧可能・履歴保持。ハード：物理削除で容量削減。"
    },
    {
      "id": "db_modeling_047",
      "question": "サロゲートキー（自動採番ID）の生成方法として最も適切なものはどれか。",
      "choices": [
        "手動入力",
        "AUTOINCREMENT/シーケンスで自動生成",
        "UUIDのみ",
        "主キー不要"
      ],
      "answer": 1,
      "explanation": "サロゲートキー：AUTOINCREMENT/シーケンスで自動生成。一意性・順序性・管理性確保。"
    },
    {
      "id": "db_modeling_048",
      "question": "複数言語対応データベース設計での文字列カラムの扱いとして最も適切なものはどれか。",
      "choices": [
        "単一言語のみ",
        "UTF-8エンコーディング、テーブル・カラムレベルでの言語対応",
        "翻訳テーブル",
        "言語無視"
      ],
      "answer": 1,
      "explanation": "多言語対応：UTF-8エンコーディング。言語ごとにカラムまたは翻訳テーブル。国際化対応。"
    },
    {
      "id": "db_modeling_049",
      "question": "大規模テーブルのバックアップと復旧戦略として最も実用的なものはどれか。",
      "choices": [
        "作業時間無視",
        "増分バックアップ、パーティション別復旧、PITR対応",
        "毎回全体",
        "復旧不要"
      ],
      "answer": 1,
      "explanation": "大規模バックアップ：増分バックアップで時間削減、パーティション別復旧で RTO短縮、PITR対応。"
    },
    {
      "id": "db_modeling_050",
      "question": "ビジネス要件変化への対応力を備えたテーブル設計の原則として最も適切なものはどれか。",
      "choices": [
        "固定スキーマ精選",
        "適度な正規化と柔軟性のバランス、バージョン管理",
        "非正規化推進",
        "設計不要"
      ],
      "answer": 1,
      "explanation": "柔軟設計：適度な正規化・属性の余裕・バージョン管理・スキーマテンプレート。ビジネス変化に対応。"
    }
  ]
}