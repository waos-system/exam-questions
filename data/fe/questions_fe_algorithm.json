{
  "genre": "アルゴリズムとプログラミング",
  "exam": "基本情報技術者試験",
  "questions": [
    {
      "id": "fe_alg_001",
      "question": "次の擬似言語の処理を実行したとき、変数xの最終的な値はどれか。\nx ← 1\nfor i ← 1 to 4\n  x ← x × i\nendfor",
      "choices": ["4", "8", "16", "24"],
      "answer": 3,
      "explanation": "x=1→i=1:x=1×1=1→i=2:x=1×2=2→i=3:x=2×3=6→i=4:x=6×4=24。これは4の階乗（4! = 24）を計算しています。"
    },
    {
      "id": "fe_alg_002",
      "question": "二分探索（バイナリサーチ）の前提条件として正しいものはどれか。",
      "choices": [
        "データがランダムに並んでいること",
        "データが昇順または降順に整列済みであること",
        "データが連結リストで格納されていること",
        "データ件数が2のべき乗であること"
      ],
      "answer": 1,
      "explanation": "二分探索は対象データが整列（ソート）されていることが前提です。中央値と比較して探索範囲を半分に絞ることを繰り返すため、計算量O(log n)で高速な探索が可能です。"
    },
    {
      "id": "fe_alg_003",
      "question": "スタック（Stack）に「A, B, C」の順でデータをプッシュし、2回ポップした後、さらに「D」をプッシュした。スタックのトップにある要素はどれか。",
      "choices": ["A", "B", "C", "D"],
      "answer": 3,
      "explanation": "Push A→B→C でスタックは[A,B,C]（Cが上）。Pop 1回でCが取り出され[A,B]。Pop 2回でBが取り出され[A]。Push D で[A,D]（Dが上）。よってトップはDです。"
    },
    {
      "id": "fe_alg_004",
      "question": "バブルソートのアルゴリズムの特徴として正しいものはどれか。",
      "choices": [
        "データを分割して再帰的にソートするアルゴリズム",
        "隣り合う要素を比較・交換する処理を繰り返すソートアルゴリズム",
        "最小値を見つけて先頭と交換するアルゴリズム",
        "ピボット要素を基準にデータを分割するアルゴリズム"
      ],
      "answer": 1,
      "explanation": "バブルソートは隣り合う要素を比較し、大小が逆なら交換する操作を繰り返します。計算量はO(n²)です。最小値選択は選択ソート、ピボット使用はクイックソート、再帰的分割はマージソートです。"
    },
    {
      "id": "fe_alg_005",
      "question": "再帰的に呼び出されるフィボナッチ数列の関数で、fib(5)の値はどれか。\nfib(0) = 0, fib(1) = 1, fib(n) = fib(n-1) + fib(n-2)",
      "choices": ["3", "5", "8", "13"],
      "answer": 1,
      "explanation": "fib(0)=0, fib(1)=1, fib(2)=1, fib(3)=2, fib(4)=3, fib(5)=fib(4)+fib(3)=3+2=5。フィボナッチ数列は0,1,1,2,3,5,8,13…と続きます。"
    },
    {
      "id": "fe_alg_006",
      "question": "連結リストとは何か。",
      "choices": [
        "データが連続したメモリ領域に格納された配列",
        "各要素が次の要素へのポインタを持ち、動的にサイズを変更できるデータ構造",
        "先入れ先出しで処理するデータ構造",
        "木構造を2分岐で表現したデータ構造"
      ],
      "answer": 1,
      "explanation": "連結リスト（Linked List）は各ノードがデータと次ノードへのポインタを持つデータ構造です。動的なサイズ変更や中間への挿入・削除がO(1)で行えますが、ランダムアクセスはO(n)です。"
    },
    {
      "id": "fe_alg_007",
      "question": "オブジェクト指向のカプセル化（Encapsulation）の説明として正しいものはどれか。",
      "choices": [
        "クラスが複数のインターフェースを実装できる性質",
        "データ（属性）と操作（メソッド）をひとまとめにし、内部実装を外部から隠蔽する",
        "子クラスが親クラスのメソッドを書き換える",
        "同じメソッド名で異なる動作を実現する"
      ],
      "answer": 1,
      "explanation": "カプセル化はデータと操作をクラスにまとめ、外部からは公開インターフェース（public）のみアクセスし、内部実装（private）を隠す概念です。変更が内部に閉じるため保守性が向上します。"
    },
    {
      "id": "fe_alg_008",
      "question": "キュー（Queue）に「P, Q, R」の順でエンキューし、2回デキューした結果として正しいものはどれか。",
      "choices": ["Rが取り出されてQのみ残る", "PとQが取り出されてRが残る", "QとRが取り出されてPが残る", "Pのみ取り出されてQとRが残る"],
      "answer": 1,
      "explanation": "キューはFIFO（先入れ先出し）です。エンキュー：P→Q→R。デキュー1回目：P（最初に入ったP）。デキュー2回目：Q。よってRが残ります。"
    },
    {
      "id": "fe_alg_009",
      "question": "ハッシュテーブルにおける「衝突」（コリジョン）とは何か。",
      "choices": [
        "2つのプロセスが同じメモリアドレスにアクセスした状態",
        "異なる2つのキーが同じハッシュ値（インデックス）に割り当てられる状態",
        "ハッシュテーブルの容量が上限に達した状態",
        "ネットワーク通信でパケットが衝突した状態"
      ],
      "answer": 1,
      "explanation": "衝突（コリジョン）は異なるキーのハッシュ関数の値が同じになることです。解決策として「チェイン法（同じインデックスをリストでつなぐ）」と「オープンアドレス法（別のインデックスを探す）」があります。"
    },
    {
      "id": "fe_alg_010",
      "question": "時間計算量O(n log n)のソートアルゴリズムはどれか。",
      "choices": ["バブルソート", "選択ソート", "挿入ソート", "マージソート"],
      "answer": 3,
      "explanation": "マージソート（クイックソート平均も含む）はO(n log n)です。バブルソート・選択ソート・挿入ソートはいずれも最悪・平均O(n²)です。マージソートは安定ソートで最悪でもO(n log n)を保証します。"
    }
  ]
}
