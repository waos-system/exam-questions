{
  "genre": "システム設計",
  "exam": "システムアーキテクト試験",
  "category": "sa_design",
  "questions": [
    {
      "id": "sa_design_001",
      "question": "システム全体の論理設計と物理設計の分離・統合を検討する際の、アーキテクト的な考慮点として最も適切なものはどれか。",
      "choices": [
        "論理設計のみで十分、物理設計は実装段階で決定",
        "業務ロジックと実装基盤を分離すれば、技術変化への適応性と保守性が向上し、複数の物理実装との対応が可能",
        "論理設計と物理設計は混在すべき",
        "分離は複雑性を増すため不合理"
      ],
      "answer": 1,
      "explanation": "論理設計（What）と物理設計（How）の分離は、アーキテクチャの本質です。この分離により、業務ロジックの安定性と、技術選択の柔軟性が両立し、システムの保守性と適応力が高まります。"
    },
    {
      "id": "sa_design_002",
      "question": "マイクロサービスアーキテクチャの設計において、サービス分割の粒度（大きさ）を決定する際の基準として最も適切なものはどれか。",
      "choices": [
        "技術的な都合で統一的な粒度を強制",
        "ビジネスケイパビリティ（ビジネス機能）単位の自律的なチーム・開発サイクルを実現できる粒度",
        "最細粒度で完全に分割すべき",
        "分割粒度は不要"
      ],
      "answer": 1,
      "explanation": "マイクロサービスは、個別チームによる自律的開発・デプロイを実現するための分割です。ビジネスケイパビリティ単位の分割により、組織的な速度と独立性が最大化されます。"
    },
    {
      "id": "sa_design_003",
      "question": "データベース設計における正規化と非正規化のバランスを判断する際、最優先で検討すべき要件として最も適切なものはどれか。",
      "choices": [
        "正規化を最大化すべき",
        "クエリ性能・更新整合性・運用負荷を総合評価し、相互トレードオフを検討",
        "非正規化により性能を優先",
        "バランス検討は不要"
      ],
      "answer": 1,
      "explanation": "完全な正規化は整合性を確保しますが、複雑なJOINクエリによる性能低下を招きます。性能要件と整合性要件を総合評価し、戦略的に非正規化かNoSQLの採用かを判断することが重要です。"
    },
    {
      "id": "sa_design_004",
      "question": "大規模分散システムの設計において、強い整合性（Strong Consistency）と最終的整合性（Eventual Consistency）のどちらを採用すべきかの判断基準として最も適切なものはどれか。",
      "choices": [
        "強い整合性を常に採用すべき",
        "金融取引等重大なデータは強い整合性、キャッシュ・分析データ等は最終的整合性で、ユースケース毎に使い分け",
        "最終的整合性が常に優位",
        "整合性方式の選択は不要"
      ],
      "answer": 1,
      "explanation": "分散システムではCAP定理の制約があり、すべての特性を同時に満たせません。業務の重大度と許容遅延時間に基づき、各データに最適な整合性戦略を設計することが重要です。"
    },
    {
      "id": "sa_design_005",
      "question": "システム全体のセキュリティアーキテクチャを設計する際、ゼロトラストセキュリティモデルを採用する利点として最も適切なものはどれか。",
      "choices": [
        "境界ベースセキュリティで十分",
        "内部脅威・侵害デバイス等に対応し、継続的な認証・認可・検証により、より包括的な身利用保護を実現",
        "ゼロトラストは導入コストが高すぎる",
        "ゼロトラストモデルは有効性がない"
      ],
      "answer": 1,
      "explanation": "従来の境界ベースセキュリティは、内部脅威や侵害されたデバイスに対応できません。ゼロトラストアーキテクチャは、身元の継続的検証により、より現代的な脅威環境に対応します。"
    },
    {
      "id": "sa_design_006",
      "question": "API設計において、REST APIとGraphQLのどちらを採用すべきかの判断基準として最も適切なものはどれか。",
      "choices": [
        "REST API を常に採用すべき",
        "多様な利用者端末・クライアント要件を精密に満たす必要がある場合GraphQL、標準的なリソース操作ならREST",
        "GraphQL が常に優位",
        "API 設計パターンの選択は不要"
      ],
      "answer": 1,
      "explanation": "REST APIはシンプルで標準的、GraphQLはクエリ柔軟性が高いです。多様なクライアント要件の場合GraphQL、標準的なリソース操作ならREST、というように、ユースケース毎に選択することが適切です。"
    },
    {
      "id": "sa_design_007",
      "question": "バッチ処理とリアルタイム処理の処理方式を選択する際の判断基準として最も適切なものはどれか。",
      "choices": [
        "バッチ方式は遅く、リアルタイム方式が常に優位",
        "データ更新の緊急度・利用者応答要件・システム負荷を評価し、適切な方式を選択（また両者の併用）",
        "リアルタイム処理はコストが高いため避ける",
        "処理方式の選択は不要"
      ],
      "answer": 1,
      "explanation": "すべてのデータがリアルタイム処理を要するわけではありません。バッチ処理で十分なデータと、リアルタイム処理が必須なデータを区別し、効率的なシステム設計が重要です。"
    },
    {
      "id": "sa_design_008",
      "question": "キャッシュアーキテクチャの設計において、キャッシュの有効性と鮮度管理のバランスを取る際の重要な考慮点として最も適切なものはどれか。",
      "choices": [
        "キャッシュの無限保持で性能を最大化",
        "キャッシュ有効期限（TTL）と無効化戦略を制御し、性能と鮮度のトレードオフを管理",
        "キャッシュは不要で、常に新鮮なデータを取得",
        "キャッシュと鮮度管理は無関係"
      ],
      "answer": 1,
      "explanation": "キャッシュは性能向上に有効ですが、古いデータ提供（鮮度低下）のリスクがあります。TTL設定と無効化戦略により、最に必要な鮮度を提供しながら、性能利益を享受することが重要です。"
    },
    {
      "id": "sa_design_009",
      "question": "クラウドネイティブなシステムアーキテクチャの設計における、従来型オンプレミスアーキテクチャとの主要な相違として最も適切なものはどれか。",
      "choices": [
        "クラウドネイティブとオンプレミスに本質的な相違はない",
        "無制限のスケーラビリティ・自動復旧・使用量ベース課金を活かした、使い捨て可能な(Cattle)リソース設計",
        "クラウドネイティブは信頼性が低い",
        "クラウドネイティブはオンプレミス設計をそのままコピーすべき"
      ],
      "answer": 1,
      "explanation": "クラウドネイティブ設計は、リソースのスケーラビリティと復旧性を前提に、個別サーバー保護でなく、全体的な耐障害性設計へのパラダイム転換です。"
    },
    {
      "id": "sa_design_010",
      "question": "マルチテナント型SaaS のシステムアーキテクチャにおいて、テナント間のリソース隔離と効率化のバランスを実現する設計パターンとして最も適切なものはどれか。",
      "choices": [
        "テナント毎に完全に独立したシステム",
        "共有インフラストラクチャ上で、テナントデータの論理的隔離とリソースの公平配分を実現するマルチテナントアーキテクチャ",
        "テナント隔離は不要で、すべてのテナントデータを混在管理",
        "隔離と効率化の両立は不可能"
      ],
      "answer": 1,
      "explanation": "マルチテナントSaaS の競争力は、テナント隔離セキュリティとスケーラビリティ効率のバランスです。共有基盤上で論理的隔離を実現することで、コスト効率と顧客信頼の両立が可能です。"
    },
    {
      "id": "sa_design_011",
      "question": "スケーラビリティ設計においては、スケールアップ（既存サーバーの強化）とスケールアウト（サーバー数追加）のどちらを優先すべきかの判断基準として最も適切なものはどれか。",
      "choices": [
        "スケールアップのみで対応",
        "成長初期段階ではスケールアップ、成長後期ではスケールアウト、システムアーキテクチャがスケールアウト対応しているか事前検証が必須",
        "スケールアウトを常に優先",
        "スケーラビリティ設計は不要"
      ],
      "answer": 1,
      "explanation": "スケールアップは単純ですがハード上限があり、スケールアウトは複雑ですが無限スケーラビリティを実現します。成長段階と技術的準備度を考慮し、段階的に移行することが実際的です。"
    },
    {
      "id": "sa_design_012",
      "question": "同期・非同期通信方式の選択における、システムの応答性能・整合性・障害耐性のバランスを考慮した設計として最も適切なものはどれか。",
      "choices": [
        "すべて同期通信で強い整合性を確保",
        "シンクロナスな応答が必須な箇所は同期、非同期で許容される箇所はメッセージキュー等数で柔軟に設計",
        "全て非同期にして複雑性を避ける",
        "通信方式の選択は不要"
      ],
      "answer": 1,
      "explanation": "すべて同期化は単純ですが性能が限定され、すべて非同期は複雑です。ユースケース毎に適切な通信方式を選択（また両者の併用）することで、応答性と安定性のバランスを取ることが重要です。"
    },
    {
      "id": "sa_design_013",
      "question": "エンタープライズシステムの監視・ロギング・トレーシング（Observability）を設計する際の、最優先で実装すべき機能として最も適切なものはどれか。",
      "choices": [
        "ロギングのみで十分",
        "メトリクス・ログ・トレースの統合収集と、異常検知・根本原因分析を可能にする分散トレーシング体制",
        "監視は本番運用開始後に構築",
        "Observability 構築は複雑すぎる"
      ],
      "answer": 1,
      "explanation": "複雑な分散システムでは、従来的なロギングのみでは問題の根本原因特定が困難です。メトリクス・ログ・トレースの統合的収集により、システム全体の健全性把握と高速なトラブル対応が可能になります。"
    },
    {
      "id": "sa_design_014",
      "question": "設計段階でのセキュリティアーキテクチャの構築（Security by Design）が重要な理由として最も適切なものはどれか。",
      "choices": [
        "運用段階でセキュリティ対策を追加する方が効率的",
        "設計段階での組み込みにより、後段階での大規模改造を回避でき、セキュリティと利便性のバランスが取りやすい",
        "セキュリティ設計は必要ない",
        "後付けセキュリティで十分"
      ],
      "answer": 1,
      "explanation": "セキュリティを後付けすると、既存デザインとの矛盾修正に膨大なコストと時間がかかります。設計段階での組み込みにより、セキュリティと利便性の均衡が取れた堅牢で使いやすいシステムが実現されます。"
    },
    {
      "id": "sa_design_015",
      "question": "レガシーシステムと新規システムの共存期間における、統合・連携アーキテクチャの設計として最も適切なものはどれか。",
      "choices": [
        "既存システム・新規システム双方に密結合させた統合",
        "明確に定義されたインターフェース（API）を通じた疎結合統合により、双方の独立的な進化を可能にする",
        "統合は避け、並行運用個別管理",
        "統合アーキテクチャは複雑すぎる"
      ],
      "answer": 1,
      "explanation": "レガシー・新規システムの混在環境では、両者が独立して進化できる疎結合統合が重要です。明確なAPI契約により、保守負荷を最小化しながら、段階的なシステム更新が実現されます。"
    },
    {
      "id": "sa_design_016",
      "question": "クラウドサービス（IaaS/PaaS/SaaS）の活用を前提とするシステムアーキテクチャ設計において、ベンダーロックイン回避の設計パターンとして最も適切なものはどれか。",
      "choices": [
        "ベンダーロックインは回避不可能",
        "標準インターフェース採用、複数ベンダー間の相互運用性確保、クライティカルデータの可搬性確保",
        "単一ベンダーに完全依存する方が効率的",
        "ベンダー依存性の検討は不要"
      ],
      "answer": 1,
      "explanation": "クラウド活用は便利ですが、ベンダーロックインリスクが存在します。標準インターフェース採用と複数ベンダー対応可能な設計により、長期的な経営選択肢の自由度を確保することが重要です。"
    },
    {
      "id": "sa_design_017",
      "question": "IoT デバイスを含むシステムアーキテクチャの設計において、デバイス管理・ファームウェア更新・タイムシンク等の運用プロセスの設計が重要な理由として最も適切なものはどれか。",
      "choices": [
        "デバイス運用は最小限に留めるべき",
        "大規模デバイス数の一括管理・セキュリティパッチの効率的配布・時刻同期による動作精度確保が、システム安定性の鍵",
        "デバイス運用は実装段階で対応できる",
        "デバイス管理は不要"
      ],
      "answer": 1,
      "explanation": "IoTシステムは数千～数百万というデバイス数を手動管理できません。集中管理基盤による自動管理・一括更新・監視体制は、大規模IoTシステムの安定稼働と セキュリティ確保の不可欠要素です。"
    },
    {
      "id": "sa_design_018",
      "question": "マイクロサービス間の通信パターン（同期RPC vs 非同期メッセージング）を設計する際、トレードオフを考慮した選択基準として最も適切なものはどれか。",
      "choices": [
        "すべて同期RPCで統一すべき",
        "即座な応答が必須な場合は同期RPC、順序保証・遅延許容業務は非同期メッセージングと使い分け",
        "非同期メッセージングのみで十分",
        "通信パターン選択は不要"
      ],
      "answer": 1,
      "explanation": "マイクロサービス通信は、ユースケース毎に適切な方式を選択することが重要です。同期RPCは単純だが結合度が高く、非同期メッセージングは複雑だが柔軟性が高いというトレードオフを理解した使い分けが必須です。"
    },
    {
      "id": "sa_design_019",
      "question": "DevOps（開発・運用統合）プラクティスを支援するシステムアーキテクチャの特徴として最も適切なものはどれか。",
      "choices": [
        "開発と運用を完全に分離すべき",
        "迅速で安全なデプロイメント自動化、継続的な監視・フィードバックループ、インフラ・コードとしての管理（Infrastructure as Code）",
        "DevOps は大型プロジェクトにのみ適用",
        "DevOps 対応アーキテクチャは複雑すぎる"
      ],
      "answer": 1,
      "explanation": "DevOps実現には、自動化・可視性・コード化されたインフラの統合的なアーキテクチャが必須です。これにより、開発と運用の敏捷性が向上し、品質と信頼性の継続的向上が実現されます。"
    },
    {
      "id": "sa_design_020",
      "question": "ブロックチェーン等の分散台帳技術を企業向けシステムに統合する際の、アーキテクチャ設計上の主要な検討課題として最も適切なものはどれか。",
      "choices": [
        "ブロックチェーンの採用は単なる技術選択",
        "取引透明性要件、スケーラビリティ・性能制約、規制対応、既存システムとの整合性、ガバナンス体制",
        "ブロックチェーンは完全な解決策である",
        "アーキテクチャ検討はブロックチェーン技術者に委ねるべき"
      ],
      "answer": 1,
      "explanation": "ブロックチェーン技術は万能ではなく、スケーラビリティと性能に課題があります。採用を検討する際は、透明性要件・規制対応・既存システム統合・運用体制を包括的に評価する必要があります。"
    },
    {
      "id": "sa_design_021",
      "question": "AI・機械学習モデルを本番環境で運用するシステムアーキテクチャの設計における、「MLOps」という概念が重要な理由として最も適切なものはどれか。",
      "choices": [
        "AIモデルは開発完了後、変更不要",
        "データドリフト・モデル性能低下に対応し、継続的な再学習・評価・デプロイを自動化する運用体制が、AI システムの持続的価値実現に不可欠",
        "機械学習モデルは本番運用に適さない",
        "MLOps は必要ない"
      ],
      "answer": 1,
      "explanation": "AI モデルは開発後も、新規データへの適応や性能低下への対応が継続的に必要です。MLOps によらデータ・モデル・システムの統合的な運用管理により、AI システムの長期的価値実現が可能になります。"
    },
    {
      "id": "sa_design_022",
      "question": "システムの今後の拡張性・保守性を確保するため、設計段階で実装すべき基本原則として最も適切なものはどれか。",
      "choices": [
        "現在の要件のみに最適化すべき",
        "関心の分離（Separation of Concerns）、DRY（Don't Repeat Yourself）、疎結合といった設計原則の実践",
        "拡張を前提とした過度な汎用化",
        "設計原則は不要"
      ],
      "answer": 1,
      "explanation": "堅牢で保守しやすいシステムは、確立された設計原則に従うことで実現されます。関心分離により変更の影響範囲を限定でき、DRYにより変更漏れを防止でき、疎結合により複数の領域を独立して進化させることが可能になります。"
    },
    {
      "id": "sa_design_023",
      "question": "従来は大規模エンタープライズシステムで採用されていた設計パターンが、最近スタートアップ企業でも採用されるようになった理由として最も適切なものはどれか。",
      "choices": [
        "大企業向けパターンは小企業には過度",
        "クラウドの普及により、スケーラビリティ・信頼性・運用性の獲得コストが劇的に低下し、小規模企業でも実装可能に",
        "スタートアップは独自の設計パターンを必要とする",
        "スタートアップはレガシーシステムのみで十分"
      ],
      "answer": 1,
      "explanation": "クラウド技術とオープンソースの進化により、大規模なスケーラビリティと高い信頼性に基づく設計パターンが、小規模企業でも経済的に実装できるようになりました。これにより、企業規模を問わず高度な技術基盤の獲得が可能になっています。"
    }
  ]
}
